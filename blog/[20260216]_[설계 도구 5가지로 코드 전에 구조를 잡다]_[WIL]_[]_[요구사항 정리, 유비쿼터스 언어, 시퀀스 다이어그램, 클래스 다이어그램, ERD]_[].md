# WIL - 설계 도구 5가지로 코드 전에 구조를 잡다

## 🧠 이번 주에 새로 배운 것

### 📋 요구사항 정리 — 사용자 니즈를 기능 명세로 전환하기

사용자가 원하는 것을 코드로 옮기려면, 그 사이에 **기능 명세**라는 다리가 필요하다는 걸 배웠다. 단순히 "회원 CRUD"라고 적는 게 아니라, **유저 시나리오 → 행위 중심 기능 목록 → 유스케이스 흐름(Main / Alternate / Exception Flow)** 순서로 정리하니까 빠뜨리는 케이스가 없어졌다.

예를 들어 같은 "주문" 기능도 관점에 따라 전혀 다른 요구사항이 나온다. 사용자 관점에서는 "여러 상품을 한 번에 주문하고 싶다"인데, 시스템 관점에서는 "재고 확인과 차감이 원자적으로 보장되어야 한다"가 된다. 이렇게 **사용자 / 비즈니스 / 시스템** 세 관점으로 나눠서 정리하니까, "아, 이건 트랜잭션으로 묶어야겠구나"라는 설계 결정이 요구사항 정리 단계에서 자연스럽게 도출됐다.

**자주 겪는 실수:** 기능 중심만 적고 예외/조건을 빠뜨리거나, 유스케이스를 너무 추상적으로 작성하는 것. 실제 흐름과 명세가 점점 벌어지면 구현 후 "이건 제가 원한 게 아니에요"를 듣게 된다.

---

### 📋 유비쿼터스 언어 — 같은 단어로 같은 개념을 말하기

DDD(도메인 주도 설계)에서 유비쿼터스 언어란, 도메인 전문가와 개발자가 **변환에 의존하지 않고 같은 언어로 소통**하기 위한 공통 언어 체계다. 이 언어는 의사소통뿐 아니라 산출물 작성, 상세 설계 모델링, 소스코드의 클래스명과 메서드명에까지 일관되게 사용된다.

"찜"이라고 할지 "좋아요"라고 할지, "상품"과 "아이템"을 어떻게 구분할지를 **문서로 먼저 합의**해두는 것이 핵심이다.

```
상품 → Product
브랜드 → Brand
좋아요 → Like
주문 → Order
```

이렇게 정해두면 기능 요구사항, ERD, API 명세, 클래스명이 전부 같은 언어를 쓰게 된다. 안 정해두면 코드에선 `wish`, 기획서에선 `favorite`, DB에선 `bookmark`가 되는 혼란이 발생한다.

또한 DDD에서는 유비쿼터스 언어가 유효한 **경계(Bounded Context)** 를 명확히 하는 것도 중요하다. 같은 "상품"이라도 주문 컨텍스트에서는 "주문 항목"이 되고, 재고 컨텍스트에서는 "재고 단위"가 되기 때문이다. 용어가 달라지는 지점이 곧 **컨텍스트의 경계**다.

---

### 📋 시퀀스 다이어그램 — "누가 무엇을 책임지는가"를 한 장으로

IBM 문서에 따르면, 시퀀스 다이어그램은 **"상호작용하는 오브젝트 간 메시지 시퀀스를 설명하는 UML 다이어그램"** 이다. 핵심 구성 요소는 네 가지다:

| 구성 요소 | 역할 |
|-----------|------|
| **라이프라인** | 상호작용에 참여하는 오브젝트 표현 |
| **메시지** | 인스턴스 간 전달되는 통신 요소 |
| **결합 단편** | 조건 분기(alt), 반복(loop) 등 제어 구조 시각화 |
| **상호작용 사용** | 기존 상호작용을 참조하여 재사용 |

개발 단계별로 활용 목적도 다르다. **분석 단계**에서는 유스케이스 실현을 위한 클래스 상호작용을 파악하고, **디자인 단계**에서는 시스템 상호작용 방식을 정제하며, **구현 단계**에서는 디자인 패턴과 메커니즘의 동작을 표시한다.

기능 하나당 하나의 시퀀스를 만들면, 각 레이어의 책임이 선명해진다. 머릿속으로 "Service가 처리하겠지"라고 생각하는 것과, 실제로 화살표를 그려보는 것은 완전히 다른 경험이었다.

**주의할 점:** 너무 많은 세부 흐름을 넣으면 오히려 복잡해지고, 시퀀스와 실제 구현이 따로 놀면 유지보수가 불가능해진다.

---

### 📋 클래스 다이어그램 & 도메인 모델 — 책임과 관계의 시각화

클래스 다이어그램은 설계를 코드로 전환할 때 자연스러운 다리가 된다. 핵심은 **엔티티/VO 분리 기준**(ID 존재 여부, 생명 주기)을 세우고, 연관 관계는 **단방향을 기본**으로, 비즈니스 책임은 도메인 객체에 포함시키는 것이다.

설계 후 반드시 **"한 객체에 책임이 몰리지 않았는가?"**를 점검해야 한다. Service에 모든 로직이 집중되거나, VO를 테이블처럼 다루려는 시도는 흔한 실수다.

---

### 📋 ERD 설계 — 도메인 모델의 물리적 구현

ERD(Entity Relationship Diagram)는 시스템에서 다루는 **데이터의 종류(Entity)**, 데이터가 갖는 **속성(Attribute)**, 데이터 간의 **연관성(Relationship)** 을 그림으로 표현한 데이터베이스 설계도다.

#### ERD의 3가지 핵심 구성요소

| 구성요소 | 설명 | 예시 |
|----------|------|------|
| **엔티티(Entity)** | 개별적으로 식별할 수 있는 물리적/추상적 개체 | 고객, 상품, 주문 |
| **속성(Attribute)** | 엔티티의 특성을 나타내는 데이터 | 고객 이름, 상품 가격 |
| **관계(Relationship)** | 두 개 이상 엔티티 간의 연관성 | 고객이 주문을 생성한다 |

#### 카디널리티(Cardinality)

카디널리티는 특정 Entity가 상대 Entity와 관계를 **몇 회 맺을 수 있는지**를 나타낸다:
- **1:1** — 한 사용자는 하나의 프로필을 가진다
- **1:N** → 외래키로 설계
- **N:M** → 조인 테이블로 설계

그 외 설계 기준:
- **enum** → VARCHAR 또는 코드 테이블
- **soft delete** → `deleted_at` 플래그
- **상태 관리** → `status` 컬럼으로 명확한 상태 전이 표현

비즈니스 흐름이 반영되지 않은 정규화만 추구하거나, 상태 컬럼 없이 코드에서 하드코딩으로 해결하는 것이 자주 겪는 실수다.

---

## 💡 핵심 정리: 설계 도구 5가지의 연결 흐름

| 순서 | 도구 | 답하는 질문 |
|------|------|------------|
| 1 | 요구사항 정리 | **무엇을** 만들어야 하는가? |
| 2 | 유비쿼터스 언어 | **어떤 말로** 소통할 것인가? |
| 3 | 시퀀스 다이어그램 | **어떤 순서로** 동작하는가? |
| 4 | 클래스 다이어그램 | **누가 어떤 책임을** 지는가? |
| 5 | ERD | **데이터를 어떻게** 저장하는가? |

이 다섯 가지가 갖춰지면, 코딩할 때 "이 메서드를 어디에 둬야 하지?"라는 고민이 사라진다. 요구사항에서 출발해서, 용어를 통일하고, 흐름을 그리고, 책임을 나누고, 저장 구조를 잡는 것 — 이 순서가 **설계의 정석**이었다.

---

## 📚 참고 자료

| 구분 | 링크 |
|------|------|
| 📚 도메인 주도 설계 | https://www.msaschool.io/operation/design/design-two/ |
| 🎬 시퀀스 다이어그램 | https://www.ibm.com/docs/ko/rsas/7.5.0?topic=uml-sequence-diagrams |
| 🗃 ERD | https://www.lucidchart.com/pages/er-diagrams |
| 📖 DDD 전략적 설계 | https://engineering-skcc.github.io/msa/DDD-StrategicDesign/ |
| 📖 DDD 유비쿼터스 언어 | https://assu10.github.io/dev/2024/07/20/ddd-domain-knowledge/ |
| 📖 ERD 구성요소 | https://datarian.io/blog/what-are-the-components-of-er-diagrams-in-dbms |

# 인터페이스를 만들면 DIP일까? — 대부분이 놓치는 한 가지

## 이 글의 목적

1. **DIP(Dependency Inversion Principle)란 무엇인가** — 정의, 왜 필요한지, 어떤 문제를 해결하는지
2. **비즈니스 모델을 순수하게 구현하는 방법** — 프레임워크에 오염되지 않는 도메인 설계 전략

실제 Kotlin + Spring Boot 프로젝트의 코드를 기반으로 설명한다.

---

## 1. DIP — "고수준이 저수준에 의존하면 안 된다"

### DIP의 정의

DIP는 SOLID 원칙의 마지막, **D**에 해당한다. Robert C. Martin(Uncle Bob)이 정의했고, 핵심은 두 가지다.

> **1. 고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.**
> **2. 추상화는 세부사항에 의존해서는 안 된다. 세부사항이 추상화에 의존해야 한다.**

여기서 말하는 고수준 모듈은 **비즈니스 로직(도메인)**이고, 저수준 모듈은 **기술적 구현(DB, 외부 API, 프레임워크)**이다.

### DIP가 없으면 어떤 일이 벌어지는가

DIP를 적용하지 않은 일반적인 구조를 보자.

```kotlin
// 도메인 서비스가 JPA Repository를 직접 의존한다
@Service
class UserService(
    private val userJpaRepository: UserJpaRepository,  // ← JPA에 직접 의존
    private val bCryptPasswordEncoder: BCryptPasswordEncoder,  // ← Spring Security에 직접 의존
) {
    fun signUp(loginId: String, password: String): User {
        val encoded = bCryptPasswordEncoder.encode(password)
        return userJpaRepository.save(User(loginId, encoded))
    }
}
```

이 코드의 문제점은 세 가지다.

**첫째, 비즈니스 로직이 기술에 종속된다.** `UserService`는 "회원가입"이라는 비즈니스를 담당하는데, JPA와 BCrypt라는 기술 결정에 묶여 있다. DB를 MongoDB로 바꾸거나 암호화를 Argon2로 바꾸면 **비즈니스 로직 코드를 수정**해야 한다.

**둘째, 단위 테스트가 어렵다.** `BCryptPasswordEncoder`는 Spring Security의 구현 클래스다. 이걸 테스트하려면 Spring Context를 띄우거나 리플렉션으로 목킹해야 한다.

**셋째, 의존성 방향이 안쪽에서 바깥쪽으로 흐른다.** 가장 중요한 도메인이 가장 자주 바뀌는 인프라에 의존하고 있다. 인프라가 바뀔 때마다 도메인이 흔들린다.

```
[도메인] → [인프라]
(고수준)    (저수준)

이 화살표 방향이 문제다.
```

### DIP를 적용하면 화살표가 역전된다

DIP의 핵심은 **화살표를 뒤집는 것**이다. 도메인이 인터페이스를 정의하고, 인프라가 그 인터페이스를 구현한다.

```
[도메인] ← [인프라]
  ↑ 인터페이스 정의    구현체 제공 ↑
```

도메인이 "나는 이런 기능이 필요해"라고 인터페이스로 선언하면, 인프라가 "내가 그걸 해줄게"라고 구현한다. **도메인은 인프라의 존재를 모른다.**

---

## 2. DIP 적용 — 인터페이스를 누가 소유하는가가 핵심이다

### 포트(Port)와 어댑터(Adapter) 패턴

DIP를 실현하는 가장 대표적인 방법이 **포트/어댑터 패턴**이다.

- **포트(Port)** = 도메인 레이어에 위치한 인터페이스. "나는 이런 기능이 필요하다"는 선언.
- **어댑터(Adapter)** = 인프라 레이어에 위치한 구현체. "내가 그 기능을 이렇게 제공할게"라는 구현.

### Repository 포트 — 도메인이 "저장/조회가 필요하다"고 선언한다

```kotlin
// domain 레이어 — 포트(인터페이스)
// 이 인터페이스는 JPA도, MySQL도, MongoDB도 모른다
interface UserRepository {
    fun findById(id: Long): User?
    fun findByLoginId(loginId: LoginId): User?
    fun existsByLoginId(loginId: LoginId): Boolean
    fun save(user: User): User
}
```

이 인터페이스가 핵심이다. **`UserRepository`는 도메인 패키지에 위치**한다. JPA import가 단 하나도 없다.

도메인 서비스는 이 인터페이스에만 의존한다.

```kotlin
// domain 레이어 — 도메인 서비스
@Component
class UserService(
    private val userRepository: UserRepository,    // ← 인터페이스 의존
    private val passwordEncoder: PasswordEncoder,  // ← 인터페이스 의존
) {
    fun signUp(loginId: String, password: String, name: String,
               email: String, birthday: LocalDate): User {
        val loginIdVo = LoginId.of(loginId)

        if (userRepository.existsByLoginId(loginIdVo)) {
            throw CoreException(ErrorType.CONFLICT, "이미 존재하는 로그인 ID 입니다.")
        }

        val encodedPassword = encodePassword(password, birthday)
        return userRepository.save(
            User(loginId = loginIdVo, password = encodedPassword, ...)
        )
    }

    private fun encodePassword(rawPassword: String, birthday: LocalDate): String {
        val validatedPassword = Password.of(rawPassword, birthday) // VO가 검증
        return passwordEncoder.encode(validatedPassword.value)
    }
}
```

`UserService`의 import를 보면 **infrastructure 패키지가 없다.** JPA도 없고, Spring Security도 없다. 순수하게 비즈니스 로직만 담고 있다.

### Repository 어댑터 — 인프라가 "JPA로 구현해줄게"라고 제공한다

```kotlin
// infrastructure 레이어 — 어댑터(구현체)
@Component
class UserRepositoryImpl(
    private val userJpaRepository: UserJpaRepository,  // ← JPA 기술 의존
) : UserRepository {  // ← 도메인 인터페이스 구현

    override fun findById(id: Long): User? =
        userJpaRepository.findByIdOrNull(id)

    override fun findByLoginId(loginId: LoginId): User? =
        userJpaRepository.findByLoginId(loginId)

    override fun existsByLoginId(loginId: LoginId): Boolean =
        userJpaRepository.existsByLoginId(loginId)

    override fun save(user: User): User =
        userJpaRepository.save(user)
}
```

```kotlin
// infrastructure 레이어 — JPA Repository (Spring Data JPA)
interface UserJpaRepository : JpaRepository<User, Long> {
    fun findByLoginId(loginId: LoginId): User?
    fun existsByLoginId(loginId: LoginId): Boolean
}
```

JPA에 대한 의존은 **infrastructure 패키지에 격리**되어 있다. 만약 MongoDB로 바꾸고 싶다면?

```kotlin
// MongoDB로 전환해도 도메인은 변경 없음
@Component
class UserMongoRepositoryImpl(
    private val userMongoRepository: UserMongoRepository,
) : UserRepository {  // ← 같은 도메인 인터페이스 구현
    override fun findById(id: Long): User? = ...
    override fun save(user: User): User = ...
}
```

**도메인 코드는 한 줄도 바뀌지 않는다.** 이것이 DIP의 힘이다.

### PasswordEncoder 포트 — 암호화 기술도 역전시킨다

도메인이 "비밀번호 암호화가 필요하다"고 선언한다.

```kotlin
// domain 레이어 — 포트
interface PasswordEncoder {
    fun encode(rawPassword: String): String
    fun matches(rawPassword: String, encodedPassword: String): Boolean
}
```

인프라가 PBKDF2로 구현한다. BCrypt든, Argon2든, SCrypt든 도메인은 관심 없다.

```kotlin
// infrastructure 레이어 — 어댑터
@Component
class Pbkdf2PasswordEncoder : PasswordEncoder {

    override fun encode(rawPassword: String): String {
        val salt = generateSalt()
        val hash = hash(rawPassword, salt)
        return "${Base64.getEncoder().encodeToString(salt)}:" +
               "${Base64.getEncoder().encodeToString(hash)}"
    }

    override fun matches(rawPassword: String, encodedPassword: String): Boolean {
        val (saltBase64, hashBase64) = encodedPassword.split(":")
            .takeIf { it.size == 2 } ?: return false
        val salt = Base64.getDecoder().decode(saltBase64)
        val expectedHash = Base64.getDecoder().decode(hashBase64)
        val actualHash = hash(rawPassword, salt)
        return actualHash.contentEquals(expectedHash)
    }

    companion object {
        private const val ITERATIONS = 10000
        private const val KEY_LENGTH = 256
        private const val ALGORITHM = "PBKDF2WithHmacSHA256"
    }
}
```

### 동시성 제어도 DIP로 — StockLockManager

주문 시 재고 차감의 동시성 제어가 필요하다. 이것도 DIP로 분리한다.

```kotlin
// application 레이어 — 포트
interface StockLockManager {
    fun acquireLocksForTransaction(productIds: List<Long>)
}
```

```kotlin
// infrastructure 레이어 — 어댑터 (현재 인메모리 구현)
@Component
class InMemoryStockLockManager : StockLockManager {
    private val locks = ConcurrentHashMap<Long, ReentrantLock>()

    override fun acquireLocksForTransaction(productIds: List<Long>) {
        val sortedIds = productIds.sorted()  // 데드락 방지: ID 오름차순 정렬
        val acquiredLocks = mutableListOf<ReentrantLock>()

        for (productId in sortedIds) {
            val lock = locks.computeIfAbsent(productId) { ReentrantLock() }
            lock.lock()
            acquiredLocks.add(lock)
        }

        // 트랜잭션 완료 시 자동 해제
        TransactionSynchronizationManager.registerSynchronization(
            object : TransactionSynchronization {
                override fun afterCompletion(status: Int) {
                    acquiredLocks.forEach { it.unlock() }
                }
            }
        )
    }
}
```

지금은 `InMemoryStockLockManager`지만, 서버가 여러 대로 늘어나면 `RedisStockLockManager`로 교체하면 된다. **application 레이어의 `OrderFacade`는 수정할 필요가 없다.**

---

## 3. 순수한 비즈니스 모델 — 프레임워크가 도메인을 오염시키지 않게 하라

### "순수하다"는 것의 의미

비즈니스 모델이 순수하다는 것은 **도메인 코드에서 프레임워크를 제거해도 비즈니스 로직이 그대로 동작한다**는 뜻이다.

Spring을 Ktor로 바꿔도, JPA를 Exposed로 바꿔도, 도메인 로직 자체는 변하지 않아야 한다. "회원가입 시 이메일 형식을 검증한다", "금액은 0 이상이어야 한다"는 규칙은 **기술 선택과 무관**하기 때문이다.

### 전략 1 — Value Object로 도메인 규칙을 캡슐화한다

Value Object(VO)는 도메인 규칙을 **객체 안에 가두는** 기법이다. String이나 Long 같은 원시 타입 대신, 의미와 규칙을 가진 타입을 만든다.

#### LoginId — 형식 규칙을 가진 식별자

```kotlin
class LoginId private constructor(
    val value: String,
) {
    override fun equals(other: Any?): Boolean =
        this === other || (other is LoginId && value == other.value)
    override fun hashCode(): Int = value.hashCode()

    companion object {
        private val LOGIN_ID_PATTERN = Regex("^[a-zA-Z0-9]+$")

        fun of(value: String): LoginId {
            validate(value)
            return LoginId(value)
        }

        private fun validate(value: String) {
            if (value.isBlank())
                throw CoreException(ErrorType.BAD_REQUEST,
                    "로그인 ID는 비어있을 수 없습니다.")
            if (!LOGIN_ID_PATTERN.matches(value))
                throw CoreException(ErrorType.BAD_REQUEST,
                    "로그인 ID는 영문과 숫자만 사용할 수 있습니다.")
        }
    }
}
```

**핵심 포인트:**
- `private constructor` — 팩토리 메서드(`of`)를 통해서만 생성 가능. 검증을 우회할 수 없다.
- `validate` — 도메인 규칙이 VO 안에 캡슐화. Controller나 Service에 검증 로직이 퍼지지 않는다.
- **import를 보면 JPA, Spring이 없다.** 순수한 Kotlin 코드다.

#### Password — 비밀번호 형식 + 생년월일 포함 여부 검증

```kotlin
class Password private constructor(val value: String) {
    companion object {
        private val PASSWORD_PATTERN = Regex(
            "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@\$!%*?&#])" +
            "[A-Za-z\\d@\$!%*?&#]{8,16}$"
        )

        fun of(rawPassword: String, birthday: LocalDate): Password {
            validateFormat(rawPassword)
            validateNotContainsBirthday(rawPassword, birthday)
            return Password(rawPassword)
        }

        private fun validateNotContainsBirthday(
            password: String, birthday: LocalDate
        ) {
            val birthdayString = birthday.toString().replace("-", "")
            if (password.contains(birthdayString))
                throw CoreException(ErrorType.BAD_REQUEST,
                    "비밀번호에 생년월일을 포함할 수 없습니다.")
        }
    }
}
```

"비밀번호에 생년월일이 포함되면 안 된다"는 **비즈니스 규칙**이다. 이 규칙이 Controller에 있으면 안 된다. Service에 흩어져 있어도 안 된다. **규칙의 주인인 Password VO 안에 있어야 한다.**

#### Money — 연산자 오버로딩으로 도메인 연산 표현

```kotlin
class Money private constructor(val value: Long) {

    operator fun plus(other: Money): Money = Money(value + other.value)
    operator fun times(quantity: Int): Money = Money(value * quantity)
    operator fun times(quantity: Quantity): Money = Money(value * quantity.value)

    companion object {
        val ZERO = Money(0)

        fun of(value: Long): Money {
            if (value < 0) throw CoreException(
                ErrorType.BAD_REQUEST, "금액은 0 이상이어야 합니다."
            )
            return Money(value)
        }
    }
}
```

`Money`는 단순한 Long이 아니다. **"금액은 음수가 될 수 없다"는 불변식**을 가진 도메인 개념이다. `Money.of(-1000)`은 컴파일은 되지만 런타임에 즉시 실패한다. 잘못된 값이 시스템에 스며드는 것을 원천 차단한다.

#### StockQuantity — 재고는 음수가 될 수 없다

```kotlin
class StockQuantity private constructor(val value: Int) {

    operator fun minus(quantity: Quantity): StockQuantity {
        val result = value - quantity.value
        if (result < 0) throw CoreException(
            ErrorType.BAD_REQUEST, "재고가 부족합니다."
        )
        return StockQuantity(result)
    }

    companion object {
        fun of(value: Int): StockQuantity {
            if (value < 0) throw CoreException(
                ErrorType.BAD_REQUEST, "재고 수량은 0 이상이어야 합니다."
            )
            return StockQuantity(value)
        }
    }
}
```

`stockQuantity - quantity`라는 **도메인 언어**로 재고 차감을 표현한다. 재고 부족 시 예외를 던지는 것도 VO의 책임이다.

### 전략 2 — Entity에 비즈니스 행위를 담는다

Entity는 데이터 덩어리가 아니다. **비즈니스 행위의 주체**다.

```kotlin
@Entity
@Table(name = "users")
class User(
    loginId: LoginId,
    password: String,
    name: String,
    birthday: LocalDate,
    email: Email,
) : BaseEntity() {

    var loginId: LoginId = loginId
        protected set  // ← 외부에서 직접 변경 불가

    var password: String = password
        protected set

    var name: String = name
        protected set

    init {
        validateName(name)  // ← 생성 시점에 도메인 규칙 검증
    }

    private fun validateName(name: String) {
        if (name.isBlank()) throw CoreException(
            ErrorType.BAD_REQUEST, "이름은 비어있을 수 없습니다."
        )
    }

    // 도메인 행위 메서드 — 외부에서 password를 꺼내서 바꾸지 않는다
    fun changePassword(encodedNewPassword: String) {
        this.password = encodedNewPassword
    }
}
```

**`protected set`의 의미가 크다.** 외부에서 `user.password = "새값"`이 안 된다. 반드시 `user.changePassword()`라는 **도메인 행위**를 통해서만 상태가 변경된다.

이것이 **"Tell, Don't Ask"** 원칙이다. 객체에게 데이터를 물어보고(getter) 외부에서 판단하지 말고, 객체에게 행위를 요청(tell)하라.

```kotlin
// Bad — 객체의 데이터를 꺼내서 외부에서 처리
val currentPassword = user.password
val newEncoded = encoder.encode(newPassword)
user.password = newEncoded  // 이게 되면 안 됨

// Good — 객체에게 행위를 요청
user.changePassword(encoder.encode(newPassword))
```

### 전략 3 — JPA 어노테이션과 비즈니스 로직을 분리한다

현실적으로 JPA Entity에 `@Entity`, `@Column` 어노테이션이 붙는 것은 피할 수 없다. 하지만 **VO와 Entity의 JPA 매핑을 인프라 레이어의 `@Converter`로 분리**할 수 있다.

```kotlin
// infrastructure 레이어 — VO ↔ DB 컬럼 변환
@Converter(autoApply = true)
class LoginIdConverter : AttributeConverter<LoginId, String> {
    override fun convertToDatabaseColumn(attribute: LoginId?): String? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: String?): LoginId? =
        dbData?.let { LoginId.of(it) }
}

@Converter(autoApply = true)
class MoneyConverter : AttributeConverter<Money, Long> {
    override fun convertToDatabaseColumn(attribute: Money?): Long? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: Long?): Money? =
        dbData?.let { Money.of(it) }
}
```

`autoApply = true`로 설정하면, Entity에 `@Convert` 어노테이션을 붙이지 않아도 자동으로 변환된다. **도메인의 VO는 JPA Converter의 존재를 전혀 모른다.**

### 전략 4 — JPA Repository 스캔 범위를 제한한다

도메인에 정의한 `UserRepository` 인터페이스가 Spring Data JPA에 의해 자동으로 Bean 등록되면 안 된다. **JPA Repository 스캔을 infrastructure 패키지로 제한**한다.

```kotlin
@Configuration
@EnableJpaRepositories(basePackages = ["com.loopers.infrastructure"])
class JpaConfig
```

이렇게 하면 `domain.user.UserRepository`는 JPA가 건드리지 않고, `infrastructure.user.UserJpaRepository`만 Spring Data JPA가 관리한다.

---

## 4. DIP가 가져다 주는 실질적 이점 — 테스트

DIP의 가장 실용적인 이점은 **단위 테스트가 쉬워진다는 것**이다.

```kotlin
@ExtendWith(MockitoExtension::class)
class UserServiceTest {
    @Mock
    private lateinit var userRepository: UserRepository     // 인터페이스 목킹
    @Mock
    private lateinit var passwordEncoder: PasswordEncoder   // 인터페이스 목킹

    private lateinit var userService: UserService

    @BeforeEach
    fun setUp() {
        userService = UserService(userRepository, passwordEncoder)
    }

    @Test
    fun `비밀번호는 암호화되어 저장된다`() {
        // given
        whenever(passwordEncoder.encode(any())).thenReturn("encoded_password")
        whenever(userRepository.existsByLoginId(any())).thenReturn(false)
        whenever(userRepository.save(any())).thenAnswer { it.arguments[0] }

        // when
        val result = userService.signUp(
            "testuser", "Test1234!@", "홍길동",
            "test@email.com", LocalDate.of(1990, 1, 15)
        )

        // then
        assertThat(result.password).isEqualTo("encoded_password")
    }
}
```

Spring Context를 띄우지 않았다. DB 연결도 없다. 순수하게 **비즈니스 로직만 테스트**하고 있다.

이것이 가능한 이유는 `UserService`가 `UserRepository` **인터페이스**에 의존하기 때문이다. 인터페이스는 Mockito로 쉽게 대체할 수 있다. 만약 `UserJpaRepository`에 직접 의존했다면, `@SpringBootTest`로 전체 컨텍스트를 올려야 했을 것이다.

---

## 5. 전체 의존성 흐름 정리

```
[interfaces]  →  [application]  →  [domain]  ←  [infrastructure]
 Controller       Facade/UseCase     Entity       RepositoryImpl
 DTO              Info               VO           JpaRepository
 ApiSpec                             Service      Converter
                                     Repository   PasswordEncoder
                                     (interface)  (impl)
```

| 레이어 | 역할 | 의존 방향 |
|--------|------|----------|
| **interfaces** | HTTP 요청/응답 처리, DTO 변환 | → application |
| **application** | 유스케이스 오케스트레이션, 트랜잭션 경계 | → domain |
| **domain** | 비즈니스 규칙, Entity, VO, 인터페이스 정의 | **아무것도 의존하지 않음** |
| **infrastructure** | DB, 외부 API, 프레임워크 기술 구현 | → domain (인터페이스 구현) |

**domain은 가장 안쪽에 위치하며, 어떤 외부 레이어도 참조하지 않는다.** 이것이 DIP가 만드는 구조다.

---

## 마무리 — DIP는 "추상화를 어디에 두느냐"의 문제다

DIP를 처음 접하면 "인터페이스를 만들면 되는 거 아니야?"라고 생각하기 쉽다. 하지만 핵심은 **인터페이스의 소유권**이다.

- `UserJpaRepository`를 `UserService`가 쓰는 건 DIP가 아니다. JPA가 정의한 인터페이스를 도메인이 의존하고 있으니까.
- `UserRepository`를 **도메인이 정의**하고, `UserRepositoryImpl`이 **인프라에서 구현**하는 것이 DIP다.

**인터페이스를 고수준(도메인)이 소유하면 DIP, 저수준(인프라)이 소유하면 DIP가 아니다.**

비즈니스 모델을 순수하게 유지하는 것도 같은 맥락이다.

1. **Value Object**로 도메인 규칙을 캡슐화한다
2. **Entity**에 비즈니스 행위를 담는다 (Tell, Don't Ask)
3. **인터페이스**를 도메인이 소유하고, 인프라가 구현한다

이 세 가지를 지키면, 프레임워크가 바뀌어도 비즈니스 로직은 살아남는다. 그리고 테스트는 빠르고 쉬워진다.

> 좋은 아키텍처란 결정을 늦출 수 있게 해주는 것이다. DB를 MySQL로 할지 PostgreSQL로 할지, 암호화를 BCrypt로 할지 Argon2로 할지는 나중에 결정해도 된다. **비즈니스 규칙이 먼저고, 기술 결정은 나중이다.**
> — Robert C. Martin, Clean Architecture

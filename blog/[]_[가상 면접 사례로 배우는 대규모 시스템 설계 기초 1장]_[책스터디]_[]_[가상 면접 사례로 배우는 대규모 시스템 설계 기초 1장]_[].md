# 1장 사용자 수에 따른 규모 확장성

## 단일 서버

- 웹 앱, 데이터베이스, 캐시 등 전부 서버 한 대에서 실행

<img src="../img/image_20250608_1.png" alt="단일 서버" width="600">

### 사용자 요청 흐름

1. 도메인 이름으로 웹사이트 접속, DNS에 질의하여 IP 주소 변환
2. 변환된 IP 주소로 HTTP 요청
3. 요청 받은 웹 서버는  HTML 페이지나 JSON 응답을 반환

#### 웹 서버 (Web Server)

- 정적인 컨텐츠(HTML, CSS, JavaScrip 파일 등)를 클라이언트에게 전달하는 역할
- 대표적인 에로 Apache, Nginx 등

#### 웹 애플리케이션 서버 (WAS, Web Application Server)

- 동적인 컨텐츠를 생성, 제공하는 역할
- 데이터베이스 조회나 다양한 로직 처리와 같은 동적인 작업 처리
- 대표적인 예로 Tomcat, JBoss, WildFly 등

## 데이터베이스

사용자가 늘면 하나의 서버로 허용할 수 있는 용량에 한계가 발생, 웹/모바일 트래픽 처리 서버와 데이터베이스 서버를 분리하여 독립적으로 확장한다.

<img src="../img/image_20250608_2.png" alt="데이터베이스 분리" width="600">

### 어떤 데이터베이스를 사용할 것인가?

#### 관계형 데이터베이스(RDBMS)

- 자료를 테이블과 열, 컬럼으로 표현한 데이터베이스
- 여러 테이블에 있는 데이터를 join 하여 조회
- 장점
    - 데이터 일관성 유지 용이
    - ACID(원자성, 일관성, 고립성, 지속성) 속성을 지원하여 데이터 무결성 보장
    - 복잡한 쿼리 수행에 적합
- 단점
    - 대량의 데이터에 대한 확장성 한계
    - 스키마 변경이 어렵고, 비용이 많이 들 수 있음

#### 비 관계형 데이터베이스(NoSQL)

- 스키마가 없거나 유연한 스키마를 가짐
- 키-값 저장소(key-value store), 그래프 저장소(graph store), 칼럼 저장소(column store), 문서 저장소(document store) 등 다양한 형태로 데이터 저장
- 장점
    - 대향의 분산된 데이터를 효율적으로 처리
    - 확장성 용이
    - 분산형 아키텍처를 활용하여 성능 최적화
    - 유연한 스키마를 통해 데이터 모델 쉽게 변경하고 적응 가능
- 단점
    - 데이터의 일관성을 보장하기 어려움
    - 복잡한 쿼리나 데이터 조인이 어렵거나 비효율적일 수 있음
    - 특정 작업에 따라 적합한 NoSQL 데이터베이스 유형을 선택해야 함

- key-value store : redis
- document store : mongodb
- graph store : neo4j
- column store : apache cassandra

## 수직적 규모 확장 VS 수평적 규모 확장

- 수직적 규모 확장
    - 스케일업(scale up), 고사양 자원을 추가하는 행위
    - 트래픽 양이 적을 때 수직적 확장이 좋음
    - 단점
        - 한 대의 서버에 CPU나 메모리를 무한대로 증설항 방법이 없음
        - 장애에 대한 자동 복구나 다중화가 안 됨
        - 따라서 대규모 애플리케이션 지원은 수평적 규모 확장이 적절
- 수평적 규모 확장
    - 스케일 아웃(scale out), 더 많은 서버 추가

### 로드밸런서

부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할

<img src="../img/image_20250608_3.png" alt="단일 서버" width="600">

로드밸런서는 공개 IP 주소로 접속한다. 웹 서버 접속은 사설 IP 주소를 이용하는데, 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소를 이용한다.

두 대의 서버 중 하나의 서버가 다운된다면 나머지 한 대의 서버로 트래픽이 전송되기에 전체 다운이 방지된다.  
웹 사이트에 유입되는 트래픽이 증가하면 현재의 서버로 감당할 수 없다면 새로운 서버를 추가하면서 로드밸런서가 자동적으로 트래픽 분산을 할 수 있다.

- 장점
    - 부하 분산
        - 여러 서버로 트래픽 분산
    - 고가용성
        - 한 대의 서버가 다운되더라도 다른 서버가 요청 처리
    - 확장성
        - 트래픽 분산을 위한 서버 추가 쉬움
    - 성능 향상
        - 최적의 서버를 선택하여 라우팅 하여 성능을 최적화 할 수 있음
- 단점
    - 단일 장애 지점
        - 로드밸런서 자체가 단일 장애 지점이 될 수 있음
    - 성능 오버헤드
        - 로드밸런서 자체에서 트래픽을 처리하는 오버헤드가 있을 수 있음
    - 관리 비용 증가

### 데이터베이스 다중화

트래픽이 증가하면 단일 장애 지점이 될 확률이 높은 곳은 데이터베이스이다. 이를 해결하기 위해 데이터베이스 다중화를 한다.  
보통 주(master)-부(slave) 관계를 설정하고, 원본 데이터는 주 서버에, 사본은 부 서버에 저장한다.

대부분의 애플리케이션은 읽기 연산의 비중이 높기 때문에 통산 부 데이터베이스의 수가 많다.

<img src="../img/image_20250608_4.png" alt="단일 서버" width="600">

- 장점
    - 더 나은 성능 : 읽기 연산이 분산되어 병렬로 처리될 수 있는 query 수가 늘어나 성능이 좋아짐
    - 안정성(reliability) : 서버 일부가 망가져도 데이터 보존 가능
    - 가용성(availability) : 서버에 장애가 발생해도 다른 곳에서 데이터 제공 가능

#### 장애 상황별

- 부 서버가 한 대 뿐이고, 다운 된다면
    - 쓰기/읽기 연산 모두 주 서버로 전달되고, 새로운 부 서버가 대체할 것이다.
- 여러 부 서버 가운데 한 대의 부 서버가 다운 된다면
    - 읽기 연산은 나머지 부 서버로 분산되고, 새로운 부 서버가 대체될 것이다.
- 주 서버가 다운 된다면
    - 한 대의 부서버만 있다면, 한 대의 부 서버가 새로운 주 서버가 되고 쓰기/읽기 연산 모두를 수행한다.
    - 그리고 새로운 부 서버가 추가 될 것이다.

주 서버가 다운된다면 데이터가 최신 상태가 아닐 수 있는데 이는 `복구 스크립트(recovery scrip)`를 실행하여 최신 상태를 맞춰야 한다.

#### 로드밸런서와 데이터베이스 다중화 설계안

<img src="../img/image_20250608_5.png" alt="단일 서버" width="600">

1. DNS로 부터 로드밸런서 공개 IP 획득
2. 로드밸런서 접속
3. HTTP 요청은 서버1 또는 서버2로 전달
4. 웹 서버는 사용자 데이터를 부 데이터베이스 서버에서 읽음
5. 데이터 업데이트 연산은 주 데이터베이스로 전달

## 캐시

값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 요청이 보다 빨리 처리될 수 있도록 하는 저장소

- 연산이 오래 걸리거나 자주 참조 되는 데이터를 메모리에 적재
- 이후 메모리에서 참조
- 애플리케이션 성능은 데이터베이스를 얼마나 자주 호출하냐에 따라 죄우

<img src="../img/image_20250608_6.png" alt="단일 서버" width="600">

- 웹서버 - 데이터베이스 사이에 별도의 캐시 위치
- 캐시를 독립적 확장도 가능

<img src="../img/image_20250608_7.jpeg" alt="단일 서버" width="600">

- Cache Aside
    - 일반적으로 사용되는 기본적인 캐시 전략
    - 캐시에 장애가 발생하더라도 데이터베이스 요청을 전달하므로 캐시 장애에 대비 가능
    - 캐시와 데이터베이스 간의 정합성 유지 문제가 발생할 수 있으며,
    - 초기 조회시 무조건 데이터베이스 호출해야 하므로 단건 호출 빈도가 높은 서비스에 적합하지 않음
    - 대신, 반복적으로 동일 쿼리를 수행하는 서비스에 적합

- Read Through
    - 캐시에서만 데이터를 읽어오는 전략
    - 데이터 조회를 전적으로 캐시에만 의지, 캐시가 다운되면 서비스 이용 차질 생김
    - 대신, 캐시와 데이터베이스간의 데이터 동기화가 항상 이루어짐

- Write Around
    - 모든 데이터는 데이터베이스에 저장 (캐시 갱신 X)
    - 캐시 미스가 발생하면 캐시에 데이터 저장
    - 따라서, 캐시와 데이터베이스 데어터 불일치가 발생 가능
    - 데이터베이스 데이터가 수정, 삭제 될 때마다 캐시 또한 변경해야 함
    - 또는 캐시 만료를 짧게 해야 함

- Write Back
    - 데이터를 저장할 때 데이터베이스에 바로 저장하지 않고, 캐시에 모아서 일정 주기 배치 작업으로 데이터베이스에 반영
    - 캐시에 모아 데이터베이스에 쓰기 때문에 쓰기 쿼리 회수 비용과 부하를 줄임
    - Write가 빈번하면서 Read를 하는데 많은 양의 Resource가 소모되는 서비스에 적합
    - 캐시에서 오류가 발생하면 데이터 영구 소실 가능

- Write Through
    - 데이터베이스와 캐시에 동시에 데이터를 저장하는 전략
    - 먼저 캐시에 데이터를 저장한 다음 바로 데이터베이스에 저장
    - 데이터베이스와 캐시가 항상 동기화 되어 있어, 캐시 데이터는 항상 최신
    - 데이터 유실이 발생하면 안 되는 상황에 적합
    - 매 요청마다 두 번의 Write가 발생해 성능 이슈 발생

#### 캐시 사용 시 유의사항
- 데이터 갱신은 드물지만 참조는 빈번한 경우 유리함
- 영속적인 데이터는 비추
- 만료정책에 대한 고민 필요
- 일관성 유지에 대한 고민 필요
- 캐시 자체가 단일 장애 지점이 될 가능성이 있음
- 캐시 메모리는 과할당이 유리
- 데이터 방출 정책 고려해야함

## 콘텐츠 전송 네트워크(CDN)

정적 콘텐츠를 전송하는데 쓰이며, 지리적으로 분산된 네트워크이다.  
이미지, 비디오, CSS, JavaScrip 파일 등을 캐시한다.

<img src="../img/image_20250608_8.png" alt="단일 서버" width="600">

#### 동작 설명

<img src="../img/image_20250608_9.png" alt="단일 서버" width="600">

1. 사용자가 이미지 URL을 이용하여 접근
2. CDN 서버에 이미지가 없는 경우, 서버는 원본 서버에 요청
3. 원본 서버가 CDN에 반환, 응답 HTTP 헤더에는 TTL 값이 들어 있다
4. CDN 서버는 파일을 캐시하고 사용자에게 반환, TTL 시간만큼 캐시됨
5. 다른 사용자가 CDN 서버에 이미지 요청
6. 만료되지 않은 이미지는 캐시를 통해 반환

#### CDN 사용 시 고려해야 할 사항

- 비용
- 만료 시한 설정
- CDN 장애 대응 방안
- 콘텐츠 무효화 방법

## 무상태(stateless) 웹 계층


# 1장 사용자 수에 따른 규모 확장성

## 단일 서버

- 웹 앱, 데이터베이스, 캐시 등 전부 서버 한 대에서 실행

<img src="../img/image_20250608_1.png" alt="단일 서버" width="600">

### 사용자 요청 흐름

1. 도메인 이름으로 웹사이트 접속, DNS에 질의하여 IP 주소 변환
2. 변환된 IP 주소로 HTTP 요청
3. 요청 받은 웹 서버는  HTML 페이지나 JSON 응답을 반환

#### 웹 서버 (Web Server)

- 정적인 컨텐츠(HTML, CSS, JavaScrip 파일 등)를 클라이언트에게 전달하는 역할
- 대표적인 에로 Apache, Nginx 등

#### 웹 애플리케이션 서버 (WAS, Web Application Server)

- 동적인 컨텐츠를 생성, 제공하는 역할
- 데이터베이스 조회나 다양한 로직 처리와 같은 동적인 작업 처리
- 대표적인 예로 Tomcat, JBoss, WildFly 등

## 데이터베이스

사용자가 늘면 하나의 서버로 허용할 수 있는 용량에 한계가 발생, 웹/모바일 트래픽 처리 서버와 데이터베이스 서버를 분리하여 독립적으로 확장한다.

<img src="../img/image_20250608_2.png" alt="데이터베이스 분리" width="600">

### 어떤 데이터베이스를 사용할 것인가?

#### 관계형 데이터베이스(RDBMS)

- 자료를 테이블과 열, 컬럼으로 표현한 데이터베이스
- 여러 테이블에 있는 데이터를 join 하여 조회
- 장점
    - 데이터 일관성 유지 용이
    - ACID(원자성, 일관성, 고립성, 지속성) 속성을 지원하여 데이터 무결성 보장
    - 복잡한 쿼리 수행에 적합
- 단점
    - 대량의 데이터에 대한 확장성 한계
    - 스키마 변경이 어렵고, 비용이 많이 들 수 있음

#### 비 관계형 데이터베이스(NoSQL)

- 스키마가 없거나 유연한 스키마를 가짐
- 키-값 저장소(key-value store), 그래프 저장소(graph store), 칼럼 저장소(column store), 문서 저장소(document store) 등 다양한 형태로 데이터 저장
- 장점
    - 대향의 분산된 데이터를 효율적으로 처리
    - 확장성 용이
    - 분산형 아키텍처를 활용하여 성능 최적화
    - 유연한 스키마를 통해 데이터 모델 쉽게 변경하고 적응 가능
- 단점
    - 데이터의 일관성을 보장하기 어려움
    - 복잡한 쿼리나 데이터 조인이 어렵거나 비효율적일 수 있음
    - 특정 작업에 따라 적합한 NoSQL 데이터베이스 유형을 선택해야 함

- key-value store : redis
- document store : mongodb
- graph store : neo4j
- column store : apache cassandra

## 수직적 규모 확장 VS 수평적 규모 확장

- 수직적 규모 확장
    - 스케일업(scale up), 고사양 자원을 추가하는 행위
    - 트래픽 양이 적을 때 수직적 확장이 좋음
    - 단점
        - 한 대의 서버에 CPU나 메모리를 무한대로 증설항 방법이 없음
        - 장애에 대한 자동 복구나 다중화가 안 됨
        - 따라서 대규모 애플리케이션 지원은 수평적 규모 확장이 적절
- 수평적 규모 확장
    - 스케일 아웃(scale out), 더 많은 서버 추가

### 로드밸런서

부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할

<img src="../img/image_20250608_3.png" alt="단일 서버" width="600">

로드밸런서는 공개 IP 주소로 접속한다. 웹 서버 접속은 사설 IP 주소를 이용하는데, 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소를 이용한다.

두 대의 서버 중 하나의 서버가 다운된다면 나머지 한 대의 서버로 트래픽이 전송되기에 전체 다운이 방지된다.  
웹 사이트에 유입되는 트래픽이 증가하면 현재의 서버로 감당할 수 없다면 새로운 서버를 추가하면서 로드밸런서가 자동적으로 트래픽 분산을 할 수 있다.

- 장점
    - 부하 분산
        - 여러 서버로 트래픽 분산
    - 고가용성
        - 한 대의 서버가 다운되더라도 다른 서버가 요청 처리
    - 확장성
        - 트래픽 분산을 위한 서버 추가 쉬움
    - 성능 향상
        - 최적의 서버를 선택하여 라우팅 하여 성능을 최적화 할 수 있음
- 단점
    - 단일 장애 지점
        - 로드밸런서 자체가 단일 장애 지점이 될 수 있음
    - 성능 오버헤드
        - 로드밸런서 자체에서 트래픽을 처리하는 오버헤드가 있을 수 있음
    - 관리 비용 증가

### 데이터베이스 다중화

트래픽이 증가하면 단일 장애 지점이 될 확률이 높은 곳은 데이터베이스이다. 이를 해결하기 위해 데이터베이스 다중화를 한다.  
보통 주(master)-부(slave) 관계를 설정하고, 원본 데이터는 주 서버에, 사본은 부 서버에 저장한다.

대부분의 애플리케이션은 읽기 연산의 비중이 높기 때문에 통산 부 데이터베이스의 수가 많다.

<img src="../img/image_20250608_4.png" alt="단일 서버" width="600">

- 장점
    - 더 나은 성능 : 읽기 연산이 분산되어 병렬로 처리될 수 있는 query 수가 늘어나 성능이 좋아짐
    - 안정성(reliability) : 서버 일부가 망가져도 데이터 보존 가능
    - 가용성(availability) : 서버에 장애가 발생해도 다른 곳에서 데이터 제공 가능

#### 장애 상황별

- 부 서버가 한 대 뿐이고, 다운 된다면
    - 쓰기/읽기 연산 모두 주 서버로 전달되고, 새로운 부 서버가 대체할 것이다.
- 여러 부 서버 가운데 한 대의 부 서버가 다운 된다면
    - 읽기 연산은 나머지 부 서버로 분산되고, 새로운 부 서버가 대체될 것이다.
- 주 서버가 다운 된다면
    - 한 대의 부서버만 있다면, 한 대의 부 서버가 새로운 주 서버가 되고 쓰기/읽기 연산 모두를 수행한다.
    - 그리고 새로운 부 서버가 추가 될 것이다.

주 서버가 다운된다면 데이터가 최신 상태가 아닐 수 있는데 이는 `복구 스크립트(recovery scrip)`를 실행하여 최신 상태를 맞춰야 한다.

#### 로드밸런서와 데이터베이스 다중화 설계안

<img src="../img/image_20250608_5.png" alt="단일 서버" width="600">

1. DNS로 부터 로드밸런서 공개 IP 획득
2. 로드밸런서 접속
3. HTTP 요청은 서버1 또는 서버2로 전달
4. 웹 서버는 사용자 데이터를 부 데이터베이스 서버에서 읽음
5. 데이터 업데이트 연산은 주 데이터베이스로 전달

## 캐시




# 정규화란 무엇인가?

정규화를 알아보기 전 정규화를 하는 이유부터 알아보자.

### 이상 현상
#### 삽입 이상
- 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제

#### 갱신 이상
- 동일한 정보가 여러 곳에 중복 저장되어 있을 경우, 한 곳에서 데이터를 수정했을 때 다른 곳에서 ㅅ정되지 않아 데이터 불일치 발생 가능

#### 삭제 이상
- 특정 데이터를 삭제하려고 할 때, 데이터까지 함께 삭제되는 데이터 손실의 문제 발생 가능

#### 정규화의 필요성
- 관련 없는 데이터들을 하나의 릴레이션에 모아두고 있기 때문에 필요
- 정규화를 통해 릴레이션을 분해하면서 해결

### 정규화
- 데이터베이스 설계 과정에서 이상 현상을 최소화하고 데이터의 일관성을 유지하기 위해 여러 개의 작은 테이블로 나누는 과정, 즉, 이상 현상을 없애는 과정이다.
- 정규화를 진행하면 이상 현상이 줄어듬
- 데이터 중복을 줄임으로서 무결성을 유지하고, 데이터 갱신 시 비정상적인 동작을 방지
- 차수가 높은 정규형에 속하는 릴레이션일수록 데이터 중복이 줄어 데이터 중복에 의한 이상 현상이 발생하지 않은 릴레이션일 수 있지만, 특성을 고려하여 적합한 정규형을 선택해야 함

#### 장점
- 데이터베이스 변경 시 이상 현상 제거 가능
- 새로운 컬럼 추가로 인한 확장 시, 구조를 변경하지 않아도 되거나 일부만 변경 가능
- 데이터베이스와 연동된 응용 프로그램에 최소한만 영향

#### 단점
- 쿼리 응답 속도가 느려질 수 있음
- JOIN 연산이 많아짐 -> 역정규화로 해결 가능

### 제 1 정규화
- `테이블 내의 모든 필드가 원자값으로만 이루어져 있어야 한다` 라는 조건을 만족하는 정규형
- 즉, 테이블의 각 컬럼에 하나의 값만 존재해야 하며, 반복되는 그룹이나 중첩된 데이터 구조가 없어야 함

![db_1_normalization.png](img/db_1_normalization.png)

### 제 2 정규화
- 제 1 정규화를 만족하면서, 테이블 내의 모든 기본키가 아닌 속성이 기본 키에 대해 완전 함수적 종속성을 가져야 한다는 조건을 만족하는 정규형
- 부분 함수적 종속성을 제거하여, 기본키의 일부에만 종속된 속성이 없어야 함
- 완전 함수 종속
    - 어떤 속성이 기본키에 대해 완전히 종속일 때
- 부분 함수 종속
    - 어떤 속성이 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부만 종속됭 때

![db_2_normalization.png](img/db_2_normalization.png)

### 제 3 정규화
- 제 2 정규화를 만족하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수적 종속이 없어야 한다는 조건을 만족하는 정규형
- 이행적 함수 종속의 경우 X -> Y, Y -> Z 이면 X -> Z가 성립함을 의미
- 즉. X를 알면 Y를 알고, 그를 통해 Z를 알 수 있다는 의미

![db_3_normalization.png](img/db_3_normalization.png)

### BCNF 정규형
- 제 3 정규형을 만족하면서, 모든 결정자가 후보키인 정규형
- 하나의 릴레이션에 여러 후보키가 존재할 경우, 제 3 정규형까지 모두 만족하더라도 이상 현상 발생 가능
- 후보키가 여러개인 릴레이션에서 발생할 수 있는 이상 현상을 해결하기 위해 사용
- 제 3 정규화는 기본키를 기준으로 종속성을 판단하지만, BCNF는 후보키를 기준으로 종속성을 판단하여 데이터베이스를 더 엄격하게 정규화

![db_bcnf_normalization.png](img/db_bcnf_normalization.png)

### 역정규화
- 성능 최적화를 위해 정규화된 데이터베이스 구조를 일부러 비정규화하는 과정
- 정규화된 구조는 데이터의 일관성과 무결셩을 높이지만, 일부 성능 저하를 초래할 수 있음, 따라서 성능을 개선하기 위해 데이터 중복을 허용하거나 테이블을 결합하는 방식으로 역정규화를 적용
- 따라서 모든 테이블을 분리하는 것이 좋은 것은 아님.

# 인터페이스를 만들면 DIP일까? 대부분이 놓치는 한 가지

## 들어가며

이번 커머스 프로젝트를 진행하면서 아키텍처를 설계할 때 가장 많이 고민한 부분이 **의존성 방향**이었다. 처음에는 "인터페이스 하나 만들면 DIP 아닌가?"라고 단순하게 생각했는데, 실제로 코드를 짜다 보니 그게 아니라는 걸 깨달았다.

이 글에서는 두 가지를 정리해보려고 한다.

1. **DIP(Dependency Inversion Principle)란 무엇인가** — 정의, 왜 필요한지, 어떤 문제를 해결하는지
2. **비즈니스 모델을 순수하게 구현하는 방법** — 프레임워크에 오염되지 않는 도메인 설계 전략

실제 Kotlin + Spring Boot 프로젝트의 코드를 기반으로 설명한다.

---

## 1. DIP — "고수준이 저수준에 의존하면 안 된다"

### DIP의 정의

DIP는 SOLID 원칙의 마지막, **D**에 해당한다. Robert C. Martin(Uncle Bob)이 정의했고, 핵심은 두 가지다.

> **1. 고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.**
> **2. 추상화는 세부사항에 의존해서는 안 된다. 세부사항이 추상화에 의존해야 한다.**

여기서 말하는 고수준 모듈은 **비즈니스 로직(도메인)**이고, 저수준 모듈은 **기술적 구현(DB, 외부 API, 프레임워크)**이다.

### DIP가 없으면 어떤 일이 벌어지는가

DIP를 적용하지 않은 일반적인 구조를 보자.

```kotlin
// 도메인 서비스가 JPA Repository를 직접 의존한다
@Service
class UserService(
    private val userJpaRepository: UserJpaRepository,  // ← JPA에 직접 의존
    private val bCryptPasswordEncoder: BCryptPasswordEncoder,  // ← Spring Security에 직접 의존
) {
    fun signUp(loginId: String, password: String): User {
        val encoded = bCryptPasswordEncoder.encode(password)
        return userJpaRepository.save(User(loginId, encoded))
    }
}
```

이 코드, 어떤 문제가 있을까? 하나씩 보자.

**비즈니스 로직이 기술에 종속된다.** `UserService`는 "회원가입"이라는 비즈니스를 담당하는데, JPA와 BCrypt라는 기술 결정에 묶여 있다. DB를 MongoDB로 바꾸거나 암호화를 Argon2로 바꾸면 **비즈니스 로직 코드를 수정**해야 한다. 이게 별거 아닌 것 같지만, 프로젝트가 커지면 기술 하나 바꾸는 데 도메인 코드를 전부 뒤져야 하는 상황이 온다.

**단위 테스트가 어렵다.** `BCryptPasswordEncoder`는 Spring Security의 구현 클래스다. 이걸 테스트하려면 Spring Context를 띄우거나 리플렉션으로 목킹해야 한다. 테스트 하나 돌리는데 몇 초씩 걸리기 시작하면, 테스트를 안 쓰게 된다.

**의존성 방향이 안쪽에서 바깥쪽으로 흐른다.** 가장 중요한 도메인이 가장 자주 바뀌는 인프라에 의존하고 있다. 인프라가 바뀔 때마다 도메인이 흔들린다.

```
[도메인] → [인프라]
(고수준)    (저수준)

이 화살표 방향이 문제다.
```

### DIP를 적용하면 화살표가 역전된다

DIP의 핵심은 **화살표를 뒤집는 것**이다. 도메인이 인터페이스를 정의하고, 인프라가 그 인터페이스를 구현한다.

```
[도메인] ← [인프라]
  ↑ 인터페이스 정의    구현체 제공 ↑
```

도메인이 "나는 이런 기능이 필요해"라고 인터페이스로 선언하면, 인프라가 "내가 그걸 해줄게"라고 구현한다. **도메인은 인프라의 존재를 모른다.**

> 결론부터 말하자면, DIP에서 진짜 중요한 건 "인터페이스를 만들었느냐"가 아니라 **"그 인터페이스를 누가 소유하느냐"**다.

---

## 2. DIP 적용 — 인터페이스를 누가 소유하는가가 핵심이다

### 포트(Port)와 어댑터(Adapter) 패턴

DIP를 실현하는 가장 대표적인 방법이 **포트/어댑터 패턴**이다.

- **포트(Port)** = 도메인 레이어에 위치한 인터페이스. "나는 이런 기능이 필요하다"는 선언.
- **어댑터(Adapter)** = 인프라 레이어에 위치한 구현체. "내가 그 기능을 이렇게 제공할게"라는 구현.

이 프로젝트에서 어떻게 적용했는지 하나씩 보자.

### Repository 포트 — 도메인이 "저장/조회가 필요하다"고 선언한다

```kotlin
// domain 레이어 — 포트(인터페이스)
// 이 인터페이스는 JPA도, MySQL도, MongoDB도 모른다
interface UserRepository {
    fun findById(id: Long): User?
    fun findByLoginId(loginId: LoginId): User?
    fun existsByLoginId(loginId: LoginId): Boolean
    fun save(user: User): User
}
```

이 인터페이스가 핵심이다. **`UserRepository`는 도메인 패키지에 위치**한다. JPA import가 단 하나도 없다.

도메인 서비스는 이 인터페이스에만 의존한다. 코드를 보자.

```kotlin
// domain 레이어 — 도메인 서비스
@Component
class UserService(
    private val userRepository: UserRepository,    // ← 인터페이스 의존
    private val passwordEncoder: PasswordEncoder,  // ← 인터페이스 의존
) {
    fun signUp(loginId: String, password: String, name: String,
               email: String, birthday: LocalDate): User {
        val loginIdVo = LoginId.of(loginId)

        if (userRepository.existsByLoginId(loginIdVo)) {
            throw CoreException(ErrorType.CONFLICT, "이미 존재하는 로그인 ID 입니다.")
        }

        val encodedPassword = encodePassword(password, birthday)
        return userRepository.save(
            User(loginId = loginIdVo, password = encodedPassword, ...)
        )
    }

    private fun encodePassword(rawPassword: String, birthday: LocalDate): String {
        val validatedPassword = Password.of(rawPassword, birthday) // VO가 검증
        return passwordEncoder.encode(validatedPassword.value)
    }
}
```

`UserService`의 import를 보면 **infrastructure 패키지가 없다.** JPA도 없고, Spring Security도 없다. 순수하게 비즈니스 로직만 담고 있다.

여기서 봐야 할 부분은 `Password.of(rawPassword, birthday)`다. 비밀번호 검증이라는 도메인 규칙이 Service에 흩어져 있지 않고, VO 안에 캡슐화되어 있다. 이건 뒤에서 더 자세히 다루겠다.

### Repository 어댑터 — 인프라가 "JPA로 구현해줄게"라고 제공한다

```kotlin
// infrastructure 레이어 — 어댑터(구현체)
@Component
class UserRepositoryImpl(
    private val userJpaRepository: UserJpaRepository,  // ← JPA 기술 의존
) : UserRepository {  // ← 도메인 인터페이스 구현

    override fun findById(id: Long): User? =
        userJpaRepository.findByIdOrNull(id)

    override fun findByLoginId(loginId: LoginId): User? =
        userJpaRepository.findByLoginId(loginId)

    override fun existsByLoginId(loginId: LoginId): Boolean =
        userJpaRepository.existsByLoginId(loginId)

    override fun save(user: User): User =
        userJpaRepository.save(user)
}
```

```kotlin
// infrastructure 레이어 — JPA Repository (Spring Data JPA)
interface UserJpaRepository : JpaRepository<User, Long> {
    fun findByLoginId(loginId: LoginId): User?
    fun existsByLoginId(loginId: LoginId): Boolean
}
```

JPA에 대한 의존은 **infrastructure 패키지에 격리**되어 있다. 만약 MongoDB로 바꾸고 싶다면?

```kotlin
// MongoDB로 전환해도 도메인은 변경 없음
@Component
class UserMongoRepositoryImpl(
    private val userMongoRepository: UserMongoRepository,
) : UserRepository {  // ← 같은 도메인 인터페이스 구현
    override fun findById(id: Long): User? = ...
    override fun save(user: User): User = ...
}
```

**도메인 코드는 한 줄도 바뀌지 않는다.** 이것이 DIP가 가져다주는 힘이다.

### 페이지네이션도 도메인 모델로 — PageQuery와 PageResult

한 가지 더 짚고 넘어가자. 상품 목록 조회에 페이지네이션이 필요한데, Spring의 `Pageable`과 `Page`를 도메인에서 직접 사용하면 Spring에 종속된다. 그래서 도메인 고유의 페이지네이션 모델을 만들었다.

```kotlin
// domain 레이어 — 도메인 고유 페이지네이션 모델
data class PageQuery(
    val page: Int,
    val size: Int,
    val sort: SortOrder = SortOrder.UNSORTED,
)

data class PageResult<T>(
    val content: List<T>,
    val page: Int,
    val size: Int,
    val totalElements: Long,
    val totalPages: Int,
) {
    fun <R> map(transform: (T) -> R): PageResult<R> = PageResult(
        content.map(transform), page, size, totalElements, totalPages,
    )
}
```

```kotlin
// domain 레이어 — 도메인 포트 (Spring Pageable 의존 없음)
interface ProductRepository {
    fun save(product: Product): Product
    fun findAll(brandId: Long?, pageQuery: PageQuery): PageResult<Product>
    fun findById(id: Long): Product?
    fun findAllByIds(ids: List<Long>): List<Product>
}
```

인프라에서 Spring의 `PageRequest`로 변환하는 건 `ProductRepositoryImpl`이 담당한다.

```kotlin
// infrastructure 레이어 — Spring Pageable 변환은 인프라가 처리
@Component
class ProductRepositoryImpl(
    private val productJpaRepository: ProductJpaRepository,
) : ProductRepository {

    override fun findAll(brandId: Long?, pageQuery: PageQuery): PageResult<Product> {
        val pageable = toPageRequest(pageQuery)
        val page = if (brandId != null) {
            productJpaRepository.findAllByBrandIdAndDeletedAtIsNull(brandId, pageable)
        } else {
            productJpaRepository.findAllByDeletedAtIsNull(pageable)
        }
        return PageResult(
            content = page.content,
            page = page.number,
            size = page.size,
            totalElements = page.totalElements,
            totalPages = page.totalPages,
        )
    }

    private fun toPageRequest(pageQuery: PageQuery): PageRequest {
        val direction = when (pageQuery.sort.direction) {
            SortOrder.Direction.ASC -> Sort.Direction.ASC
            SortOrder.Direction.DESC -> Sort.Direction.DESC
        }
        return PageRequest.of(pageQuery.page, pageQuery.size, Sort.by(direction, pageQuery.sort.property))
    }
}
```

> 이렇게 하면 도메인의 `ProductRepository`는 Spring의 `Pageable`이 뭔지 전혀 모른다. Spring Data를 Exposed나 다른 라이브러리로 교체해도 도메인 코드는 그대로다.

### PasswordEncoder 포트 — 암호화 기술도 역전시킨다

도메인이 "비밀번호 암호화가 필요하다"고 선언한다.

```kotlin
// domain 레이어 — 포트
interface PasswordEncoder {
    fun encode(rawPassword: String): String
    fun matches(rawPassword: String, encodedPassword: String): Boolean
}
```

인프라가 PBKDF2로 구현한다. BCrypt든, Argon2든, SCrypt든 도메인은 관심 없다.

```kotlin
// infrastructure 레이어 — 어댑터
@Component
class Pbkdf2PasswordEncoder : PasswordEncoder {

    override fun encode(rawPassword: String): String {
        val salt = generateSalt()
        val hash = hash(rawPassword, salt)
        return "${Base64.getEncoder().encodeToString(salt)}:" +
               "${Base64.getEncoder().encodeToString(hash)}"
    }

    override fun matches(rawPassword: String, encodedPassword: String): Boolean {
        val (saltBase64, hashBase64) = encodedPassword.split(":")
            .takeIf { it.size == 2 } ?: return false
        val salt = Base64.getDecoder().decode(saltBase64)
        val expectedHash = Base64.getDecoder().decode(hashBase64)
        val actualHash = hash(rawPassword, salt)
        return actualHash.contentEquals(expectedHash)
    }

    private fun generateSalt(): ByteArray =
        ByteArray(SALT_LENGTH).apply { SecureRandom().nextBytes(this) }

    private fun hash(password: String, salt: ByteArray): ByteArray {
        val spec = PBEKeySpec(password.toCharArray(), salt, ITERATIONS, KEY_LENGTH)
        val factory = SecretKeyFactory.getInstance(ALGORITHM)
        return factory.generateSecret(spec).encoded
    }

    companion object {
        private const val ITERATIONS = 10000
        private const val KEY_LENGTH = 256
        private const val SALT_LENGTH = 16
        private const val ALGORITHM = "PBKDF2WithHmacSHA256"
    }
}
```

처음에는 Spring Security의 `BCryptPasswordEncoder`를 바로 주입해서 쓸까 고민했다. 하지만 그렇게 하면 도메인 서비스가 Spring Security에 직접 의존하게 된다. 지금처럼 도메인에 `PasswordEncoder` 인터페이스를 정의하고, 인프라에서 PBKDF2로 구현하면 나중에 암호화 알고리즘을 바꾸더라도 도메인은 건드릴 필요가 없다.

### 동시성 제어도 DIP로 — StockLockManager

주문할 때 재고 차감의 동시성 제어가 필요하다. 이것도 DIP로 분리했다.

```kotlin
// application 레이어 — 포트
interface StockLockManager {

    /**
     * 상품 ID 목록에 대해 락을 획득하고, 트랜잭션 완료 후 자동으로 해제한다.
     * 데드락 방지를 위해 productId 오름차순으로 락을 획득한다.
     */
    fun acquireLocksForTransaction(productIds: List<Long>)
}
```

```kotlin
// infrastructure 레이어 — 어댑터 (현재 인메모리 구현)
@Component
class InMemoryStockLockManager : StockLockManager {
    private val locks = ConcurrentHashMap<Long, ReentrantLock>()

    override fun acquireLocksForTransaction(productIds: List<Long>) {
        val sortedIds = productIds.sorted()  // 데드락 방지: ID 오름차순 정렬
        val acquiredLocks = mutableListOf<ReentrantLock>()

        for (productId in sortedIds) {
            val lock = locks.computeIfAbsent(productId) { ReentrantLock() }
            lock.lock()
            acquiredLocks.add(lock)
        }

        // 트랜잭션 완료 시 자동 해제
        TransactionSynchronizationManager.registerSynchronization(
            object : TransactionSynchronization {
                override fun afterCompletion(status: Int) {
                    acquiredLocks.forEach { it.unlock() }
                }
            }
        )
    }
}
```

지금은 단일 서버라서 `InMemoryStockLockManager`로 충분하다. 하지만 서버가 여러 대로 늘어나면 `RedisStockLockManager`로 교체하면 된다. **application 레이어의 `OrderFacade`는 수정할 필요가 없다.** 이런 유연성이 DIP를 적용하는 실질적인 이유다.

---

## 3. 순수한 비즈니스 모델 — 프레임워크가 도메인을 오염시키지 않게 하라

### "순수하다"는 것의 의미

비즈니스 모델이 순수하다는 건 **도메인 코드에서 프레임워크를 제거해도 비즈니스 로직이 그대로 동작한다**는 뜻이다.

Spring을 Ktor로 바꿔도, JPA를 Exposed로 바꿔도, 도메인 로직 자체는 변하지 않아야 한다. "회원가입 시 이메일 형식을 검증한다", "금액은 0 이상이어야 한다"는 규칙은 **기술 선택과 무관**하기 때문이다.

그렇다면 어떻게 순수하게 유지할 수 있을까? 이 프로젝트에서 적용한 전략들을 하나씩 보자.

### 전략 1 — Value Object로 도메인 규칙을 캡슐화한다

Value Object(VO)는 도메인 규칙을 **객체 안에 가두는** 기법이다. String이나 Long 같은 원시 타입 대신, 의미와 규칙을 가진 타입을 만든다.

이 프로젝트에서 만든 VO들을 보자.

#### LoginId — 형식 규칙을 가진 식별자

```kotlin
class LoginId private constructor(
    val value: String,
) {
    override fun equals(other: Any?): Boolean =
        this === other || (other is LoginId && value == other.value)
    override fun hashCode(): Int = value.hashCode()

    companion object {
        private val LOGIN_ID_PATTERN = Regex("^[a-zA-Z0-9]+$")

        fun of(value: String): LoginId {
            validate(value)
            return LoginId(value)
        }

        private fun validate(value: String) {
            if (value.isBlank())
                throw CoreException(ErrorType.BAD_REQUEST,
                    "로그인 ID는 비어있을 수 없습니다.")
            if (!LOGIN_ID_PATTERN.matches(value))
                throw CoreException(ErrorType.BAD_REQUEST,
                    "로그인 ID는 영문과 숫자만 사용할 수 있습니다.")
        }
    }
}
```

여기서 봐야 할 포인트는 세 가지다.

- `private constructor` — 팩토리 메서드(`of`)를 통해서만 생성 가능하다. 검증을 우회할 수 없다.
- `validate` — 도메인 규칙이 VO 안에 캡슐화되어 있다. Controller나 Service에 검증 로직이 퍼지지 않는다.
- **import를 보면 JPA, Spring이 없다.** 순수한 Kotlin 코드다.

#### Email — 이메일 형식 검증도 VO의 책임

```kotlin
class Email private constructor(
    val value: String,
) {
    override fun equals(other: Any?): Boolean =
        this === other || (other is Email && value == other.value)
    override fun hashCode(): Int = value.hashCode()

    companion object {
        private val EMAIL_PATTERN = Regex("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$")

        fun of(value: String): Email {
            validate(value)
            return Email(value)
        }

        private fun validate(value: String) {
            if (value.isBlank())
                throw CoreException(ErrorType.BAD_REQUEST, "이메일은 비어있을 수 없습니다.")
            if (!EMAIL_PATTERN.matches(value))
                throw CoreException(ErrorType.BAD_REQUEST, "올바른 이메일 형식이 아닙니다.")
        }
    }
}
```

"이메일 형식이 맞는지 확인해야 하는데, 이 로직을 어디에 둘까?"라는 질문에 대한 답이 VO다. Controller에서 `@Valid`로 검증하는 방법도 있지만, 그러면 도메인 규칙이 프레임워크에 의존하게 된다. VO 안에 넣으면 어디에서 `Email.of(value)`를 호출하든 검증이 보장된다.

#### Password — 비밀번호 형식 + 생년월일 포함 여부 검증

```kotlin
class Password private constructor(val value: String) {
    companion object {
        private val PASSWORD_PATTERN = Regex(
            "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@\$!%*?&#])" +
            "[A-Za-z\\d@\$!%*?&#]{8,16}$"
        )

        fun of(rawPassword: String, birthday: LocalDate): Password {
            validateFormat(rawPassword)
            validateNotContainsBirthday(rawPassword, birthday)
            return Password(rawPassword)
        }

        private fun validateFormat(password: String) {
            if (!PASSWORD_PATTERN.matches(password))
                throw CoreException(ErrorType.BAD_REQUEST,
                    "비밀번호는 8~16자의 영문 대소문자, 숫자, 특수문자를 포함해야 합니다.")
        }

        private fun validateNotContainsBirthday(
            password: String, birthday: LocalDate
        ) {
            val birthdayString = birthday.toString().replace("-", "")
            if (password.contains(birthdayString))
                throw CoreException(ErrorType.BAD_REQUEST,
                    "비밀번호에 생년월일을 포함할 수 없습니다.")
        }
    }
}
```

"비밀번호에 생년월일이 포함되면 안 된다"는 **비즈니스 규칙**이다. 이 규칙이 Controller에 있으면 안 된다. Service에 흩어져 있어도 안 된다. **규칙의 주인인 Password VO 안에 있어야 한다.** 나중에 "비밀번호에 연속된 숫자 3자리 이상 불가"같은 규칙이 추가되더라도, 이 VO만 수정하면 된다.

#### Money — 연산자 오버로딩으로 도메인 연산 표현

```kotlin
class Money private constructor(val value: Long) {

    operator fun plus(other: Money): Money = Money(value + other.value)
    operator fun times(quantity: Int): Money = Money(value * quantity)
    operator fun times(quantity: Quantity): Money = Money(value * quantity.value)

    companion object {
        val ZERO = Money(0)

        fun of(value: Long): Money {
            if (value < 0) throw CoreException(
                ErrorType.BAD_REQUEST, "금액은 0 이상이어야 합니다."
            )
            return Money(value)
        }
    }
}
```

`Money`는 단순한 Long이 아니다. **"금액은 음수가 될 수 없다"는 불변식**을 가진 도메인 개념이다. `Money.of(-1000)`은 컴파일은 되지만 런타임에 즉시 실패한다. 잘못된 값이 시스템에 스며드는 것을 원천 차단한다.

Kotlin의 연산자 오버로딩 덕분에 `price * quantity`처럼 도메인 언어 그대로 코드를 작성할 수 있다. 나중에 Order Entity에서 이걸 어떻게 활용하는지 보자.

#### Quantity — 주문 수량은 0보다 커야 한다

```kotlin
class Quantity private constructor(
    val value: Int,
) {
    override fun equals(other: Any?): Boolean =
        this === other || (other is Quantity && value == other.value)
    override fun hashCode(): Int = value.hashCode()

    companion object {
        fun of(value: Int): Quantity {
            if (value <= 0)
                throw CoreException(ErrorType.BAD_REQUEST, "수량은 0보다 커야 합니다.")
            return Quantity(value)
        }
    }
}
```

"수량이 0이거나 음수인 주문"이 시스템에 들어오면 안 된다. 이 검증을 Service에서 `if (quantity <= 0)` 체크하는 대신, 타입 자체가 보장하도록 만들었다. `Quantity.of(0)`을 호출하면 즉시 예외가 발생한다.

#### StockQuantity — 재고는 음수가 될 수 없다

```kotlin
class StockQuantity private constructor(val value: Int) {

    operator fun minus(other: Quantity): StockQuantity {
        val result = value - other.value
        if (result < 0) throw CoreException(
            ErrorType.BAD_REQUEST, "재고가 부족합니다."
        )
        return StockQuantity(result)
    }

    companion object {
        fun of(value: Int): StockQuantity {
            if (value < 0) throw CoreException(
                ErrorType.BAD_REQUEST, "재고 수량은 0 이상이어야 합니다."
            )
            return StockQuantity(value)
        }
    }
}
```

`stockQuantity - quantity`라는 **도메인 언어**로 재고 차감을 표현한다. 재고 부족 시 예외를 던지는 것도 VO의 책임이다. 여기서 `minus`의 파라미터가 `Int`가 아니라 `Quantity`인 것에 주목하자. 검증된 수량만 차감에 사용할 수 있다.

#### LikeCount — 좋아요 수도 도메인 규칙이 있다

```kotlin
class LikeCount private constructor(
    val value: Int,
) {
    fun increment(): LikeCount = LikeCount(value + 1)

    fun decrement(): LikeCount = if (value > 0) LikeCount(value - 1) else this

    companion object {
        fun of(value: Int): LikeCount {
            if (value < 0)
                throw CoreException(ErrorType.BAD_REQUEST, "좋아요 수는 0 이상이어야 합니다.")
            return LikeCount(value)
        }
    }
}
```

`decrement()`를 보면, 좋아요 수가 0일 때 음수로 내려가지 않고 자기 자신을 반환한다. 이런 **방어적 로직이 VO 안에 캡슐화**되어 있기 때문에, Service에서 "좋아요 수가 0인지 먼저 확인하고 감소시키는" 코드를 따로 쓸 필요가 없다.

### 전략 2 — Entity에 비즈니스 행위를 담는다

Entity는 데이터 덩어리가 아니다. **비즈니스 행위의 주체**다.

#### User Entity — 상태 변경은 반드시 도메인 행위를 통해서

```kotlin
@Entity
@Table(name = "users")
class User(
    loginId: LoginId,
    password: String,
    name: String,
    birthday: LocalDate,
    email: Email,
) : BaseEntity() {

    var loginId: LoginId = loginId
        protected set  // ← 외부에서 직접 변경 불가

    var password: String = password
        protected set

    var name: String = name
        protected set

    var birthday: LocalDate = birthday
        protected set

    var email: Email = email
        protected set

    init {
        validateName(name)  // ← 생성 시점에 도메인 규칙 검증
    }

    private fun validateName(name: String) {
        if (name.isBlank()) throw CoreException(
            ErrorType.BAD_REQUEST, "이름은 비어있을 수 없습니다."
        )
    }

    // 도메인 행위 메서드 — 외부에서 password를 꺼내서 바꾸지 않는다
    fun changePassword(encodedNewPassword: String) {
        this.password = encodedNewPassword
    }
}
```

**`protected set`의 의미가 크다.** 외부에서 `user.password = "새값"`이 안 된다. 반드시 `user.changePassword()`라는 **도메인 행위**를 통해서만 상태가 변경된다.

이것이 **"Tell, Don't Ask"** 원칙이다. 객체에게 데이터를 물어보고(getter) 외부에서 판단하지 말고, 객체에게 행위를 요청(tell)하라.

```kotlin
// Bad — 객체의 데이터를 꺼내서 외부에서 처리
val currentPassword = user.password
val newEncoded = encoder.encode(newPassword)
user.password = newEncoded  // 이게 되면 안 됨

// Good — 객체에게 행위를 요청
user.changePassword(encoder.encode(newPassword))
```

#### Product Entity — 재고 차감, 좋아요가 비즈니스 행위다

Product Entity에는 좀 더 풍부한 비즈니스 메서드가 있다. 보자.

```kotlin
@Entity
@Table(name = "products")
class Product(
    name: String,
    description: String?,
    price: Money,
    likes: LikeCount,
    stockQuantity: StockQuantity,
    brandId: Long,
) : BaseEntity() {

    var name: String = name
        protected set

    var price: Money = price
        protected set

    var likes: LikeCount = likes
        protected set

    var stockQuantity: StockQuantity = stockQuantity
        protected set

    var brandId: Long = brandId
        protected set

    init {
        validateName(name)
    }

    private fun validateName(name: String) {
        if (name.isBlank())
            throw CoreException(ErrorType.BAD_REQUEST, "상품 이름은 비어있을 수 없습니다.")
    }

    // 비즈니스 메서드: 좋아요 증가
    fun increaseLikeCount() {
        this.likes = this.likes.increment()
    }

    // 비즈니스 메서드: 좋아요 감소
    fun decreaseLikeCount() {
        this.likes = this.likes.decrement()
    }

    // 비즈니스 메서드: 재고 차감
    fun deductStock(quantity: Quantity) {
        this.stockQuantity = this.stockQuantity - quantity
    }
}
```

여기서 `deductStock(quantity)`를 보자. 재고 차감이라는 비즈니스 행위가 Entity 안에 있다. 그리고 내부적으로 `StockQuantity`의 `minus` 연산을 호출하는데, 재고가 부족하면 VO 레벨에서 즉시 예외가 발생한다. **Entity와 VO가 협력해서 비즈니스 규칙을 보호**하고 있다.

"재고를 까야 하니까 `product.stockQuantity.value`를 꺼내서 직접 빼자"가 아니라, `product.deductStock(quantity)`로 **행위를 요청**하는 것이 핵심이다.

#### Order Entity — 가장 풍부한 비즈니스 로직

주문 Entity는 이 프로젝트에서 비즈니스 로직이 가장 많은 곳이다. 코드를 보자.

```kotlin
@Entity
@Table(name = "orders")
class Order(
    userId: Long,
    status: OrderStatus = OrderStatus.ORDERED,
) : BaseEntity() {

    var userId: Long = userId
        protected set

    var totalAmount: Money = Money.ZERO
        protected set

    var status: OrderStatus = status
        protected set

    @OneToMany(mappedBy = "order", cascade = [CascadeType.ALL], orphanRemoval = true)
    @SQLRestriction("deleted_at IS NULL")
    private val orderItems: MutableList<OrderItem> = mutableListOf()

    val items: List<OrderItem>
        get() = orderItems.toList()

    // 비즈니스 메서드: 주문 항목 추가 (빈 항목/중복 상품 검증)
    fun addItems(items: List<OrderItemCommand>) {
        if (items.isEmpty()) {
            throw CoreException(ErrorType.BAD_REQUEST, "주문 항목이 비어있습니다.")
        }
        val productIds = items.map { it.productId }
        if (productIds.size != productIds.toSet().size) {
            throw CoreException(ErrorType.BAD_REQUEST, "중복된 상품이 포함되어 있습니다.")
        }
        items.forEach { addItem(it) }
    }

    private fun addItem(item: OrderItemCommand) {
        orderItems.add(
            OrderItem(
                order = this,
                productId = item.productId,
                quantity = item.quantity,
                productName = item.productName,
                productPrice = item.productPrice,
                brandName = item.brandName,
            ),
        )
        calculateTotalAmount()
    }

    // 비즈니스 메서드: 총 주문 금액 계산
    private fun calculateTotalAmount() {
        this.totalAmount = orderItems.fold(Money.ZERO) { acc, item ->
            acc + item.productPrice * item.quantity
        }
    }
}
```

여기서 눈여겨볼 부분이 여러 가지 있다.

**`addItems()`에서 빈 주문과 중복 상품을 검증한다.** "주문 항목이 비어있으면 안 된다", "같은 상품이 중복되면 안 된다"는 도메인 규칙이 Entity 안에 있다. Service에서 이런 검증을 하지 않는다.

**`calculateTotalAmount()`에서 VO의 연산자 오버로딩이 빛난다.** `acc + item.productPrice * item.quantity`라는 코드가 가능한 이유는 `Money`에 `plus`, `times` 연산자를 정의했기 때문이다. 도메인 언어 그대로 코드를 읽을 수 있다.

**`orderItems`는 `private`이고, 외부에는 `items`라는 읽기 전용 프로퍼티만 노출한다.** `orderItems.toList()`로 복사본을 반환하기 때문에, 외부에서 `order.items.add(...)`를 해도 원본이 바뀌지 않는다. 반드시 `addItems()`를 통해서만 항목을 추가할 수 있다.

### 전략 3 — JPA 어노테이션과 비즈니스 로직을 분리한다

현실적으로 JPA Entity에 `@Entity`, `@Column` 어노테이션이 붙는 것은 피할 수 없다. 하지만 **VO와 Entity의 JPA 매핑을 인프라 레이어의 `@Converter`로 분리**할 수 있다.

```kotlin
// infrastructure 레이어 — VO ↔ DB 컬럼 변환
@Converter(autoApply = true)
class LoginIdConverter : AttributeConverter<LoginId, String> {
    override fun convertToDatabaseColumn(attribute: LoginId?): String? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: String?): LoginId? =
        dbData?.let { LoginId.of(it) }
}

@Converter(autoApply = true)
class MoneyConverter : AttributeConverter<Money, Long> {
    override fun convertToDatabaseColumn(attribute: Money?): Long? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: Long?): Money? =
        dbData?.let { Money.of(it) }
}

@Converter(autoApply = true)
class StockQuantityConverter : AttributeConverter<StockQuantity, Int> {
    override fun convertToDatabaseColumn(attribute: StockQuantity?): Int? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: Int?): StockQuantity? =
        dbData?.let { StockQuantity.of(it) }
}

@Converter(autoApply = true)
class QuantityConverter : AttributeConverter<Quantity, Int> {
    override fun convertToDatabaseColumn(attribute: Quantity?): Int? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: Int?): Quantity? =
        dbData?.let { Quantity.of(it) }
}

@Converter(autoApply = true)
class LikeCountConverter : AttributeConverter<LikeCount, Int> {
    override fun convertToDatabaseColumn(attribute: LikeCount?): Int? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: Int?): LikeCount? =
        dbData?.let { LikeCount.of(it) }
}

@Converter(autoApply = true)
class EmailConverter : AttributeConverter<Email, String> {
    override fun convertToDatabaseColumn(attribute: Email?): String? =
        attribute?.value
    override fun convertToEntityAttribute(dbData: String?): Email? =
        dbData?.let { Email.of(it) }
}
```

`autoApply = true`로 설정하면, Entity에 `@Convert` 어노테이션을 붙이지 않아도 자동으로 변환된다. **도메인의 VO는 JPA Converter의 존재를 전혀 모른다.**

> 이 패턴의 진짜 가치는 "DB에 어떤 타입으로 저장되는가"라는 결정이 인프라 레이어에 격리된다는 것이다. VO는 순수한 도메인 객체로 남는다.

### 전략 4 — JPA Repository 스캔 범위를 제한한다

도메인에 정의한 `UserRepository` 인터페이스가 Spring Data JPA에 의해 자동으로 Bean 등록되면 안 된다. **JPA Repository 스캔을 infrastructure 패키지로 제한**한다.

```kotlin
@Configuration
@EnableTransactionManagement
@EntityScan(basePackages = ["com.loopers"])
@EnableJpaRepositories(basePackages = ["com.loopers.infrastructure"])
class JpaConfig
```

이렇게 하면 `domain.user.UserRepository`는 JPA가 건드리지 않고, `infrastructure.user.UserJpaRepository`만 Spring Data JPA가 관리한다. 이거 안 하면 Spring이 도메인의 `UserRepository`를 보고 "이것도 JPA Repository인가?"라고 착각할 수 있다.

---

## 4. Application 레이어 — 유스케이스 오케스트레이션

DIP 이야기를 하면서 application 레이어를 빼놓을 수 없다. 이 레이어의 역할은 **도메인 서비스들을 조합**해서 하나의 유스케이스를 완성하는 것이다. 직접 비즈니스 로직을 수행하지 않고, 도메인 서비스에 위임한다.

주문 생성 흐름을 보자. `OrderFacade.placeOrder()`가 어떻게 여러 도메인 서비스를 조합하는지 확인할 수 있다.

```kotlin
@Component
class OrderFacade(
    private val orderService: OrderService,
    private val productService: ProductService,
    private val brandService: BrandService,
    private val stockLockManager: StockLockManager,  // ← 인터페이스 의존
) {

    @Transactional
    fun placeOrder(userId: Long, items: List<OrderPlaceCommand>) {
        val productIds = items.map { it.productId }

        // 1. 재고 차감 동시성 제어: 락 획득 후 트랜잭션 커밋 시 자동 해제
        stockLockManager.acquireLocksForTransaction(productIds)

        // 2. 락 획득 후 상품 재조회 (최신 재고 상태 보장) + 존재 검증
        val products = productService.getProductsForOrder(productIds)
        val productMap = products.associateBy { it.id }

        // 3. 브랜드 정보 조회 (주문 스냅샷용)
        val brandMap = brandService.getBrandsByIds(
            products.map { it.brandId }.distinct(),
        ).associateBy { it.id }

        // 4. 재고 차감 (도메인 서비스에 위임)
        val deductionRequests = items.map { StockDeductionRequest(it.productId, it.quantity) }
        productService.deductStocks(productMap, deductionRequests)

        // 5. 주문 생성 (cross-domain 스냅샷 조립은 application 레이어에서)
        val orderItemCommands = items.map { item ->
            val product = productMap.getValue(item.productId)
            val brand = brandMap.getValue(product.brandId)
            OrderItemCommand(
                productId = item.productId,
                quantity = item.quantity,
                productName = product.name,
                productPrice = product.price,
                brandName = brand.name,
            )
        }

        orderService.createOrder(userId, orderItemCommands)
    }
}
```

이 코드에서 주목할 점이 몇 가지 있다.

**`stockLockManager`가 인터페이스라는 것.** `OrderFacade`는 락이 인메모리인지 Redis인지 관심 없다. DIP 덕분에 인프라 교체가 자유롭다.

**각 단계가 도메인 서비스에 위임된다는 것.** `productService.deductStocks()`, `orderService.createOrder()` 등 실제 비즈니스 로직은 도메인 서비스가 수행한다. application 레이어는 순서를 조율할 뿐이다.

**cross-domain 데이터 조합이 application 레이어에서 일어난다는 것.** 주문 항목에 상품명과 브랜드명을 스냅샷으로 저장하는데, Product 도메인과 Brand 도메인의 데이터를 조합하는 건 도메인 서비스의 역할이 아니다. 이건 유스케이스 레벨의 관심사이므로 application 레이어가 담당한다.

> 도메인 서비스가 비즈니스 규칙을 지키는 "무엇(what)"을 담당한다면, application 레이어는 "어떤 순서로 조합할 것인가(how to orchestrate)"를 담당한다.

---

## 5. DIP가 가져다 주는 실질적 이점 — 테스트

DIP의 가장 실용적인 이점은 **단위 테스트가 쉬워진다는 것**이다. 코드를 보자.

```kotlin
@ExtendWith(MockitoExtension::class)
class UserServiceTest {
    @Mock
    private lateinit var userRepository: UserRepository     // 인터페이스 목킹
    @Mock
    private lateinit var passwordEncoder: PasswordEncoder   // 인터페이스 목킹

    private lateinit var userService: UserService

    @BeforeEach
    fun setUp() {
        userService = UserService(userRepository, passwordEncoder)
    }

    @Test
    fun `비밀번호는 암호화되어 저장된다`() {
        // given
        whenever(passwordEncoder.encode(any())).thenReturn("encoded_password")
        whenever(userRepository.existsByLoginId(any())).thenReturn(false)
        whenever(userRepository.save(any())).thenAnswer { it.arguments[0] }

        // when
        val result = userService.signUp(
            "testuser", "Test1234!@", "홍길동",
            "test@email.com", LocalDate.of(1990, 1, 15)
        )

        // then
        assertThat(result.password).isEqualTo("encoded_password")
    }
}
```

Spring Context를 띄우지 않았다. DB 연결도 없다. 순수하게 **비즈니스 로직만 테스트**하고 있다.

이것이 가능한 이유는 `UserService`가 `UserRepository` **인터페이스**에 의존하기 때문이다. 인터페이스는 Mockito로 쉽게 대체할 수 있다. 만약 `UserJpaRepository`에 직접 의존했다면, `@SpringBootTest`로 전체 컨텍스트를 올려야 했을 것이다. 테스트 하나에 수 초가 걸리고, 테스트가 많아지면 CI 파이프라인이 느려지는 악순환이 시작된다.

---

## 6. 전체 의존성 흐름 정리

```
[interfaces]  →  [application]  →  [domain]  ←  [infrastructure]
 Controller       Facade/UseCase     Entity       RepositoryImpl
 DTO              Info               VO           JpaRepository
 ApiSpec          Command            Service      Converter
                  StockLockManager   Repository   PasswordEncoder
                  (interface)        (interface)  (impl)
```

| 레이어 | 역할 | 의존 방향 |
|--------|------|----------|
| **interfaces** | HTTP 요청/응답 처리, DTO 변환 | → application |
| **application** | 유스케이스 오케스트레이션, 트랜잭션 경계 | → domain |
| **domain** | 비즈니스 규칙, Entity, VO, 인터페이스 정의 | **아무것도 의존하지 않음** |
| **infrastructure** | DB, 외부 API, 프레임워크 기술 구현 | → domain (인터페이스 구현) |

**domain은 가장 안쪽에 위치하며, 어떤 외부 레이어도 참조하지 않는다.** 이것이 DIP가 만드는 구조다.

---

## 마무리 — DIP는 "추상화를 어디에 두느냐"의 문제다

처음에 나도 "인터페이스만 만들면 DIP 아닌가?"라고 생각했다. 하지만 이번 프로젝트를 진행하면서 깨달은 건, 핵심은 **인터페이스의 소유권**이라는 것이다.

- `UserJpaRepository`를 `UserService`가 쓰는 건 DIP가 아니다. JPA가 정의한 인터페이스를 도메인이 의존하고 있으니까.
- `UserRepository`를 **도메인이 정의**하고, `UserRepositoryImpl`이 **인프라에서 구현**하는 것이 DIP다.

**인터페이스를 고수준(도메인)이 소유하면 DIP, 저수준(인프라)이 소유하면 DIP가 아니다.**

비즈니스 모델을 순수하게 유지하는 것도 같은 맥락이다.

1. **Value Object**로 도메인 규칙을 캡슐화한다
2. **Entity**에 비즈니스 행위를 담는다 (Tell, Don't Ask)
3. **인터페이스**를 도메인이 소유하고, 인프라가 구현한다
4. **JPA Converter**로 VO-DB 매핑을 인프라에 격리한다

이 네 가지를 지키면, 프레임워크가 바뀌어도 비즈니스 로직은 살아남는다. 그리고 테스트는 빠르고 쉬워진다.

이번 프로젝트에서 DIP를 적용하면서 가장 크게 느낀 건, 아키텍처 결정이 코드의 변경 용이성에 직접적인 영향을 준다는 것이다. 지금은 인메모리 락을 쓰고 있지만, 서버를 스케일아웃할 때 Redis 분산 락으로 교체하더라도 도메인과 application 코드는 한 줄도 안 바꿔도 된다. 이게 DIP가 주는 실질적인 가치라고 생각한다.

> 좋은 아키텍처란 결정을 늦출 수 있게 해주는 것이다. DB를 MySQL로 할지 PostgreSQL로 할지, 암호화를 BCrypt로 할지 Argon2로 할지는 나중에 결정해도 된다. **비즈니스 규칙이 먼저고, 기술 결정은 나중이다.**
> — Robert C. Martin, Clean Architecture

# 11장 뉴스 피드 시스템 설계

뉴스 피드는 지속적으로 업데이트되는 스토리들, 사용자 상태 정보 업데이트, 사진, 비디오, 링크, 앱 활동 등 포함

### 1단계 문제 이해 및 설계 범위 확정

- 앱, 웹 둘다 지원
- 사용자는 새로운 뉴스 피드 등록 가능, 친구들이 업로드한 뉴스 피드 보기 가능
- 뉴스 피드는 시간 흐름 역순으로 조회
- 한 명의 사용자는 최대 5000명의 친구 가질 수 있음
- 매일 천만 명 방문
- 뉴스 피드에는 이미지나 비디오 등의 미디어 파일 업로드 가능

### 2단계 개략적 설계안 제시 및 동의 구하기

- 피드 발행 : 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스레 저장, 새 포스팅은 친구 뉴스 피드에 전송
- 뉴스 피드 생성 : 뉴스 피드는 모든 친구 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정

#### 뉴스 피드 API

클라이언트가 서버와 통신하기 위한 수단  
HTTP 프로토콜 기반, 상태 정보를 업데이트, 뉴스 피드 가져오기, 친구 추가 등 다양한 작업 수행

##### 피드 발행 API

새 스토리를 포스팅하기 위햔 API  
POST /v1/me/feed
- 인자
  - body : 포스팅 내용
  - Authorization 헤더 : API 호출 인증하기 위해 사용

##### 피드 읽기 API

뉴스 피드를 가져오는 API  
GET /v1/me/feed
- 인자
  - Authorization 헤더 : API 호출 인증하기 위해 사용

##### 피드 발행

![image_20250716_1.png](img/image_20250716_1.png)

- 사용자 : 모바일 앱, 브라우저에서 새 포스팅 업로드 주체
  - POST /v1/me/feed API 사용
- 로드밸런서 : 트래픽을 웹 서버로 분산
- 웹 서버 : HTTP 요청을 내부 서비스로 중계 역할
- 포스팅 저장 서비스 : 새 포스팅을 데이터베잉스와 캐시에 저장
- 포스팅 전송 서비스 : 새 포스팅을 친구와 뉴스 피드에 푸시, 뉴스 피드 데이터는 캐시에 보관, 빠르게 읽기 가능
- 알림 서비스 : 친구에게 새 포스팅 업로드 시, 푸시 알림 보내는 역할

##### 뉴스 피드 생성

![image_20250716_2.png](img/image_20250716_2.png)

- 사용자 : 뉴스 피드를 읽는 주체
  - GET /v1/me/feed API
- 로드 밸런서 : 트래픽을 웹 서버에 분산
- 웹 서버 : 트래픽을 뉴스 피드 서비스에 보냄
- 뉴스 피드 서비스 : 캐시에서 뉴스 피드 가져옴
- 뉴스 피드 캐시 : 뉴스 피드 랜더링할 때 필요한 피드 ID 보관

### 3단계 상세 설계

#### 피드 발행 흐름 상세 설계

![image_20250716_3.png](img/image_20250716_3.png)

##### 웹 서버

- 클라이언트와 통신
- 인증, 처리율 제한 등 기능 수행
- 스팸을 막고 유해한 콘텐츠가 자주 올라오는 것 방지를 위해 특정 기간 동안 한 사용자 올릴 포스팅 수에 제한

##### 포스팅 전송(팬아웃) 서비스

- 팬아웃은 새 포스팅을 업로드 시 그 사용자의 친구 모두에게 전달하는 과정
- 팬아웃은 두 가지 모델 있음
  - 쓰기 시점 팬아웃(푸시 모델)
    - 새로운 포스팅을 기록하는 시점에 뉴스 피드 갱신
    - 즉, 포스팅이 완료되면 바로 해당 사용자 캐시에 해당 포스팅 기록
    - 장점
      - 뉴스 피스 실시간 갱신, 친구들에게 즉시 전송
      - 뉴스 피드를 읽는 시간이 짧음
    - 단점
      - 친구가 많으면 뉴스 피드 갱신에 많은 시간 소요, 핫키(hotkey) 라고도 함
      - 서비스를 자주 이용하지 않은 사용자도 갱신, 컴퓨팅 자원 낭비
  - 읽기 시점 팬아웃(풀 모델)
    - 피드를 읽어야 하는 시점에 뉴스 피드 갱신, 요청 기반 모델
    - 사용자가 본인 홈페이지나 타임라인 로딩하는 시점에 새로운 포스트 가져옴
    - 장점
      - 비활성화 사용자, 가끔 사용하는 사용자의 경우 유리, 컴퓨팅 자원 덜 소모
      - 데이터를 친구 각각에 푸시하는 작업이 없어 핫키 문제 생기지 않음
    - 단점
      - 뉴스 피드 읽는데 많은 시간 소요

두 가지 방법을 결합하여 장점은 취하고 단점은 버리는 전략을 취할 것임
- 뉴스 피드를 빠르게 가져오기 위해 푸시 모델 사용
- 친구가 많으면 포스팅이 필요할 때 가져가도록 풀 모델 사용, 시스템 과부하 방지
- 안정 해시를 통해 요청과 데이터를 보다 고르게 분산하여 핫키 문제 줄임

![image_20250716_4.png](img/image_20250716_4.png)

1. 그래프 데이터베이스에서 친구 ID 목록을 가져옴, 그래프 데이터베이스는 친구 관계나 친구 추천 관리에 적합
2. 사용자 정보 캐시에서 친구들 정보 가져옴
3. 친구 목록과 새 스토리의 포스팅 Id를 메시지 큐에 넣음
4. 팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내 뉴스 피드  캐시에 넣음
  - (포스팅ID, 사용자ID)의 순서쌍을 보관
  - 적정 수준의 메모리 크기를 위해 크기 제한
  - 수천 개의 스토리를 전부 볼 확률은 낮기에 캐시 미스 확률 낮음

#### 피드 읽기 흐름 상세 설계

![image_20250716_5.png](img/image_20250716_5.png)

1. 사용자가 뉴스 피드 읽기 요청 보냄
2. 로드밸런서가 웹 서버 가운데 하나로 요청
3. 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스 호출
4. 뉴스 피드 서비스는 캐시에서 포스팅ID 목록 가져옴
5. 뉴스 피드에 표시할 정보들을 캐시에서 가져와 뉴스 피드 만듬
6. 생성된 뉴스 피드 JSON 형태로 클라이언트에 보냄

##### 캐시 구조

![image_20250716_6.png](img/image_20250716_6.png)

- 뉴스 피드 : 뉴스 피드의 ID 보관
- 콘텐츠 : 포스팅 데이터 보관, 인기 콘텐츠 따로 보관
- 소셜 그래프 : 사용자 간 관계 정보 보관
- 행동 : 포스팅에 대한 사용자의 행위에 관한 정보 보관
- 횟수 : '좋아요' 횟수, 응답 수, 팔로어 수, 팔로잉 수 등 정보 보관

### 4단계 마무리

다루면 좋은 주제

- 데이터베이스 규모 확장
  - 수직적 규모 확장 <-> 수평적 규모 확장
  - SQL vs NoSQL
  - replication 다중화
  - 복제본에 대한 읽기 연산
  - 일관성 모델
  - 데이터베이스 샤딩
- 웹 계층을 무상태로 운영하기
- 가능한 많은 데이터 캐시 방법
- 여러 데이터 센터 지원 방법
- 메시지 큐 사용하여 컴포넌트 사이의 결합도 낮추기
- 핵심 메트릭에 대한 모니터링
  - 트래픽이 몰리는 시간 QPS
  - 사용자가 뉴스 피드를 새로고침 할 때 지연 시간

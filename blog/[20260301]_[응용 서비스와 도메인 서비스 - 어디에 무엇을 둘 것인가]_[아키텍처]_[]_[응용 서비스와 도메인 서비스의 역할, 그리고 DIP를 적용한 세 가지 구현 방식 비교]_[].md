# 응용 서비스와 도메인 서비스 - 어디에 무엇을 둘 것인가

## 들어가며

"서비스"라는 단어는 개발에서 가장 남용되는 용어 중 하나다. Spring을 쓰다 보면 모든 것이 `@Service`가 되고, 그 안에 모든 로직이 들어간다. 하지만 DDD(Domain-Driven Design) 관점에서 서비스는 두 종류로 나뉜다. **응용 서비스(Application Service)**와 **도메인 서비스(Domain Service)**. 이 둘의 역할과 책임을 명확히 구분하지 않으면, 결국 모든 로직이 한 곳에 뭉치는 **서비스 레이어 비대화(Fat Service)** 문제에 빠진다.

이 글에서는 응용 서비스와 도메인 서비스가 무엇인지 정리하고, 의존성을 어떻게 설계하느냐에 따라 코드 구조가 어떻게 달라지는지 세 가지 방식으로 비교한다.

---

## 응용 서비스(Application Service)란?

응용 서비스는 **유스케이스를 조율하는 계층**이다. 비즈니스 로직 자체를 구현하지 않고, 도메인 객체들을 **조합하고 흐름을 제어**하는 역할을 한다.

### 핵심 책임
- 트랜잭션 관리
- 여러 도메인 서비스 / 도메인 객체 조합
- DTO 변환 (도메인 → 외부 응답)
- 인프라 기술(락, 이벤트 발행 등) 오케스트레이션

### 하지 않는 것
- 도메인 규칙 검증
- 비즈니스 로직 구현
- 도메인 상태 직접 변경

한 마디로 정리하면, 응용 서비스는 **"무엇을 할지"를 결정하고, "어떻게 할지"는 도메인에 위임**한다.

---

## 도메인 서비스(Domain Service)란?

도메인 서비스는 **도메인 로직 중 특정 엔티티에 속하기 어려운 로직**을 담당한다. 엔티티 자체가 처리할 수 없거나, 여러 엔티티를 조합해야 하는 비즈니스 규칙이 여기에 해당한다.

### 핵심 책임
- 도메인 규칙 검증
- 비즈니스 로직 수행
- 도메인 객체 생성/조회/수정 위임

### 하지 않는 것
- 트랜잭션 관리 (응용 서비스의 책임)
- DTO 변환
- 외부 기술 의존 (JPA, HTTP 등)

### 엔티티 vs 도메인 서비스, 어디에 로직을 둘까?

| 기준 | 엔티티 | 도메인 서비스 |
|------|--------|-------------|
| 자신의 상태만 변경 | O | |
| 자기 검증 (invariant) | O | |
| 여러 엔티티 필요 | | O |
| Repository 접근 필요 | | O |
| 외부 인터페이스 호출 필요 | | O |

---

## 의존성 설계에 따른 세 가지 방식

이제 본론이다. 도메인 서비스가 데이터에 접근하는 방식을 세 가지로 나눠서 비교한다.

---

## 방식 1: 도메인 서비스에서 JpaRepository를 직접 DI

가장 흔하게 볼 수 있는 방식이다. 도메인 서비스가 Spring Data JPA의 `JpaRepository`를 직접 주입받는다.

### 구조

```
domain/
  └── product/
        ├── Product.kt           # 엔티티
        └── ProductService.kt    # 도메인 서비스 (JpaRepository 직접 의존)

infrastructure/
  └── product/
        └── ProductJpaRepository.kt  # Spring Data JPA
```

### 코드 예제

```kotlin
// infrastructure/product/ProductJpaRepository.kt
interface ProductJpaRepository : JpaRepository<Product, Long> {
    fun findByIdAndDeletedAtIsNull(id: Long): Product?
    fun findAllByDeletedAtIsNull(pageable: Pageable): Page<Product>
    fun findAllByBrandIdAndDeletedAtIsNull(brandId: Long): List<Product>
}
```

```kotlin
// domain/product/ProductService.kt
@Service
class ProductService(
    private val productJpaRepository: ProductJpaRepository,  // 인프라 직접 의존
) {

    fun getProduct(productId: Long): Product {
        return productJpaRepository.findByIdAndDeletedAtIsNull(productId)
            ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다.")
    }

    fun createProduct(
        name: String,
        description: String?,
        price: Money,
        stockQuantity: StockQuantity,
        brandId: Long,
    ): Product {
        return productJpaRepository.save(
            Product.create(
                name = name,
                description = description,
                price = price,
                stockQuantity = stockQuantity,
                brandId = brandId,
            ),
        )
    }

    fun deductStocks(products: Map<Long, Product>, requests: List<StockDeductionRequest>) {
        for (request in requests) {
            products.getValue(request.productId).deductStock(request.quantity)
        }
    }

    fun deleteAllByBrandId(brandId: Long) {
        val products = productJpaRepository.findAllByBrandIdAndDeletedAtIsNull(brandId)
        products.forEach { it.delete() }
    }
}
```

### 문제점

```
도메인 서비스 ──의존──▶ JpaRepository (인프라 기술)
```

**도메인 계층이 인프라스트럭처 기술에 직접 의존한다.** 이것은 DIP 위반이다.

- `JpaRepository`의 메서드 시그니처(`Pageable`, `Page` 등)가 도메인 코드에 침투한다.
- `findByIdAndDeletedAtIsNull` 같은 구현 세부사항이 도메인에 노출된다.
- JPA를 다른 기술(MongoDB, R2DBC 등)로 교체하면 **도메인 서비스 코드가 변경**된다.
- 테스트 시 Spring Context를 띄우거나 JPA 관련 설정이 필요하다.

이 방식이 "동작은 하지만 설계적으로 올바르지 않은" 이유는, **비즈니스의 핵심인 도메인이 기술적 세부사항에 종속**되기 때문이다.

---

## 방식 2: 도메인에 Repository 인터페이스를 두고, 인프라에 구현체를 만드는 방식 (DIP)

**의존성 역전 원칙(DIP)**을 적용한 방식이다. 도메인 계층에 인터페이스를 정의하고, 인프라 계층에서 이를 구현한다.

### 구조

```
domain/
  └── product/
        ├── Product.kt              # 엔티티
        ├── ProductRepository.kt    # 도메인 인터페이스
        └── ProductService.kt       # 도메인 서비스 (도메인 인터페이스 의존)

infrastructure/
  └── product/
        ├── ProductJpaRepository.kt     # Spring Data JPA
        └── ProductRepositoryImpl.kt    # 도메인 인터페이스 구현체
```

### 코드 예제

**1단계: 도메인에 인터페이스 정의**

```kotlin
// domain/product/ProductRepository.kt
interface ProductRepository {
    fun save(product: Product): Product
    fun findAll(brandId: Long?, pageQuery: PageQuery): PageResult<Product>
    fun findById(id: Long): Product?
    fun findAllByIds(ids: List<Long>): List<Product>
    fun findAllByBrandId(brandId: Long): List<Product>
}
```

이 인터페이스에는 JPA의 흔적이 없다. `Pageable`이 아닌 도메인 고유의 `PageQuery`, `Page`가 아닌 `PageResult`를 사용한다. 도메인의 언어로 데이터 접근을 표현한다.

**2단계: 인프라에 구현체 작성**

```kotlin
// infrastructure/product/ProductJpaRepository.kt
interface ProductJpaRepository : JpaRepository<Product, Long> {
    fun findByIdAndDeletedAtIsNull(id: Long): Product?
    fun findAllByDeletedAtIsNull(pageable: Pageable): Page<Product>
    fun findAllByBrandIdAndDeletedAtIsNull(brandId: Long, pageable: Pageable): Page<Product>
    fun findAllByBrandIdAndDeletedAtIsNull(brandId: Long): List<Product>
    fun findAllByIdInAndDeletedAtIsNull(ids: List<Long>): List<Product>
}
```

```kotlin
// infrastructure/product/ProductRepositoryImpl.kt
@Component
class ProductRepositoryImpl(
    private val productJpaRepository: ProductJpaRepository,
) : ProductRepository {

    override fun save(product: Product): Product {
        return productJpaRepository.save(product)
    }

    override fun findAll(brandId: Long?, pageQuery: PageQuery): PageResult<Product> {
        val pageable = pageQuery.toPageRequest()
        val page = if (brandId != null) {
            productJpaRepository.findAllByBrandIdAndDeletedAtIsNull(brandId, pageable)
        } else {
            productJpaRepository.findAllByDeletedAtIsNull(pageable)
        }
        return page.toPageResult()
    }

    override fun findById(id: Long): Product? {
        return productJpaRepository.findByIdAndDeletedAtIsNull(id)
    }

    override fun findAllByIds(ids: List<Long>): List<Product> {
        return productJpaRepository.findAllByIdInAndDeletedAtIsNull(ids)
    }

    override fun findAllByBrandId(brandId: Long): List<Product> {
        return productJpaRepository.findAllByBrandIdAndDeletedAtIsNull(brandId)
    }
}
```

**3단계: 도메인 서비스는 인터페이스에만 의존**

```kotlin
// domain/product/ProductService.kt
@Component
class ProductService(
    private val productRepository: ProductRepository,  // 도메인 인터페이스 의존
) {

    fun getProduct(productId: Long): Product {
        return productRepository.findById(productId)
            ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다.")
    }

    fun createProduct(
        name: String,
        description: String?,
        price: Money,
        stockQuantity: StockQuantity,
        brandId: Long,
    ): Product {
        return productRepository.save(
            Product.create(
                name = name,
                description = description,
                price = price,
                stockQuantity = stockQuantity,
                brandId = brandId,
            ),
        )
    }

    fun deductStocks(products: Map<Long, Product>, requests: List<StockDeductionRequest>) {
        for (request in requests) {
            products.getValue(request.productId).deductStock(request.quantity)
        }
    }

    fun deleteAllByBrandId(brandId: Long) {
        val products = productRepository.findAllByBrandId(brandId)
        products.forEach { it.delete() }
    }
}
```

### 의존성 흐름

```
도메인 서비스 ──의존──▶ ProductRepository (도메인 인터페이스)
                                ▲
                                │ 구현
ProductRepositoryImpl ──의존──▶ ProductJpaRepository (인프라 기술)
```

**의존성이 역전**되었다. 도메인은 인프라를 모르고, 인프라가 도메인을 구현한다.

### 장점

- 도메인 코드에 JPA 흔적이 없다.
- JPA를 MongoDB, R2DBC로 바꿔도 **도메인 코드는 변경 없이** 구현체만 교체하면 된다.
- 테스트 시 인메모리 구현체나 Mock으로 쉽게 대체 가능하다.
- 도메인의 순수성이 보장된다.

### Repository 외에도 적용 가능

이 패턴은 Repository에만 국한되지 않는다. 도메인이 의존하는 모든 기술적 세부사항에 적용할 수 있다.

```kotlin
// domain/user/PasswordEncoder.kt - 도메인 인터페이스
interface PasswordEncoder {
    fun encode(rawPassword: String): String
    fun matches(rawPassword: String, encodedPassword: String): Boolean
}
```

```kotlin
// infrastructure/user/Pbkdf2PasswordEncoder.kt - 인프라 구현체
@Component
class Pbkdf2PasswordEncoder : PasswordEncoder {

    override fun encode(rawPassword: String): String {
        val salt = generateSalt()
        val hash = hash(rawPassword, salt)
        return "${Base64.getEncoder().encodeToString(salt)}:${Base64.getEncoder().encodeToString(hash)}"
    }

    override fun matches(rawPassword: String, encodedPassword: String): Boolean {
        val (saltBase64, hashBase64) = encodedPassword.split(":").takeIf { it.size == 2 } ?: return false
        val salt = Base64.getDecoder().decode(saltBase64)
        val hash = Base64.getDecoder().decode(hashBase64)
        val inputHash = hash(rawPassword, salt)
        return hash.contentEquals(inputHash)
    }

    // ... 해싱 로직
}
```

```kotlin
// domain/user/UserService.kt - 도메인 서비스
@Component
class UserService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,  // 인터페이스에만 의존
) {
    fun signUp(loginId: String, password: String, name: String, email: String, birthday: LocalDate): User {
        val loginIdVo = LoginId.of(loginId)
        if (userRepository.existsByLoginId(loginIdVo)) {
            throw CoreException(ErrorType.CONFLICT, "이미 존재하는 로그인 ID 입니다.")
        }

        val validatedPassword = Password.of(password, birthday)
        val encodedPassword = passwordEncoder.encode(validatedPassword.value)

        return userRepository.save(
            User(loginId = loginIdVo, password = encodedPassword, name = name, email = Email.of(email), birthday = birthday)
        )
    }
}
```

PBKDF2에서 BCrypt로 알고리즘을 바꾸더라도 `UserService`는 한 줄도 바뀌지 않는다. 이것이 DIP의 힘이다.

---

## 방식 3: 응용 서비스에서 JpaRepository를 DI하고, 도메인 서비스에 도메인을 파라미터로 전달

도메인 서비스를 완전히 순수하게 만드는 방식이다. 데이터 접근은 응용 서비스가 담당하고, 도메인 서비스에는 이미 조회된 도메인 객체를 넘긴다.

### 구조

```
domain/
  └── product/
        ├── Product.kt              # 엔티티
        └── ProductService.kt       # 도메인 서비스 (의존성 없음, 순수 로직)

application/
  └── product/
        └── ProductFacade.kt        # 응용 서비스 (JpaRepository 의존)

infrastructure/
  └── product/
        └── ProductJpaRepository.kt # Spring Data JPA
```

### 코드 예제

```kotlin
// domain/product/ProductService.kt
@Component
class ProductService {
    // Repository 의존성이 전혀 없다

    fun validateAndDeductStocks(products: Map<Long, Product>, requests: List<StockDeductionRequest>) {
        for (request in requests) {
            val product = products[request.productId]
                ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다: ${request.productId}")
            product.deductStock(request.quantity)
        }
    }

    fun validateBrandChange(product: Product, newBrandId: Long) {
        product.validateBrandChange(newBrandId)
    }

    fun deleteAll(products: List<Product>) {
        products.forEach { it.delete() }
    }
}
```

```kotlin
// application/product/ProductFacade.kt
@Component
class ProductFacade(
    private val productJpaRepository: ProductJpaRepository,  // 인프라 직접 의존
    private val productService: ProductService,               // 도메인 서비스
    private val brandService: BrandService,
) {

    fun getProduct(productId: Long): ProductDetailInfo {
        val product = productJpaRepository.findByIdAndDeletedAtIsNull(productId)
            ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다.")
        val brand = brandService.getBrand(product.brandId)
        return ProductDetailInfo.from(product, brand)
    }

    @Transactional
    fun updateProduct(
        productId: Long,
        name: String,
        description: String?,
        price: Money,
        stockQuantity: StockQuantity,
        brandId: Long,
    ) {
        val product = productJpaRepository.findByIdAndDeletedAtIsNull(productId)
            ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다.")

        // 도메인 검증은 도메인 서비스에 위임
        productService.validateBrandChange(product, brandId)

        // 도메인 로직 실행
        product.update(name, description, price, stockQuantity)
    }

    @Transactional
    fun deleteAllByBrandId(brandId: Long) {
        val products = productJpaRepository.findAllByBrandIdAndDeletedAtIsNull(brandId)
        // 도메인 로직(삭제 처리)은 도메인 서비스에 위임
        productService.deleteAll(products)
    }
}
```

### 문제점

이 방식은 도메인 서비스는 순수해지지만, **여러 가지 문제**가 생긴다.

**1. 응용 서비스가 인프라에 직접 의존한다**

```
응용 서비스 ──의존──▶ JpaRepository (인프라 기술)
응용 서비스 ──의존──▶ 도메인 서비스
```

응용 서비스가 `findByIdAndDeletedAtIsNull` 같은 인프라의 세부사항을 직접 알아야 한다. 방식 1의 문제가 응용 서비스로 옮겨간 것뿐이다.

**2. 도메인 서비스의 역할이 애매해진다**

도메인 서비스가 데이터를 조회하지 못하면, 자기 완결적인 비즈니스 로직을 수행하기 어렵다. 응용 서비스가 필요한 데이터를 전부 조회해서 넘겨야 하므로, **응용 서비스가 도메인 흐름을 너무 많이 알아야** 한다.

**3. 유스케이스가 복잡해지면 응용 서비스가 비대해진다**

```kotlin
// 주문 생성 유스케이스 - 응용 서비스가 모든 조회를 담당해야 한다
@Transactional
fun placeOrder(userId: Long, items: List<OrderPlaceCommand>) {
    val productIds = items.map { it.productId }
    val products = productJpaRepository.findAllByIdInAndDeletedAtIsNull(productIds)  // 직접 조회
    val productMap = products.associateBy { it.id }

    val brandIds = products.map { it.brandId }.distinct()
    val brands = brandJpaRepository.findAllByIdInAndDeletedAtIsNull(brandIds)  // 직접 조회
    val brandMap = brands.associateBy { it.id }

    // 도메인 서비스에 위임하지만, 모든 데이터를 응용 서비스가 준비
    productService.validateAndDeductStocks(productMap, items.map { StockDeductionRequest(it.productId, it.quantity) })

    // ... 주문 생성 로직
}
```

결국 응용 서비스가 "조율자"가 아니라 "만능 처리자"가 되어버린다.

### 개선: 방식 3 + DIP 적용

방식 3의 핵심 아이디어(도메인 서비스는 순수하게, 데이터 조회는 바깥에서)를 유지하면서, **응용 서비스가 인프라에 직접 의존하는 문제**를 DIP로 해결할 수 있다.

#### 구조

```
domain/
  └── product/
        ├── Product.kt              # 엔티티
        ├── ProductRepository.kt    # 도메인 인터페이스 (추가)
        └── ProductService.kt       # 도메인 서비스 (의존성 없음, 순수 로직)

application/
  └── product/
        └── ProductFacade.kt        # 응용 서비스 (도메인 인터페이스 의존)

infrastructure/
  └── product/
        ├── ProductJpaRepository.kt     # Spring Data JPA
        └── ProductRepositoryImpl.kt    # 도메인 인터페이스 구현체 (추가)
```

#### 코드 예제

```kotlin
// domain/product/ProductRepository.kt - 도메인 인터페이스
interface ProductRepository {
    fun save(product: Product): Product
    fun findById(id: Long): Product?
    fun findAllByIds(ids: List<Long>): List<Product>
    fun findAllByBrandId(brandId: Long): List<Product>
}
```

```kotlin
// domain/product/ProductService.kt - 순수 도메인 로직만 담당
@Component
class ProductService {
    // Repository 의존성 없음. 도메인 객체만 받아서 비즈니스 규칙 수행

    fun validateAndDeductStocks(products: Map<Long, Product>, requests: List<StockDeductionRequest>) {
        for (request in requests) {
            val product = products[request.productId]
                ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다: ${request.productId}")
            product.deductStock(request.quantity)
        }
    }

    fun validateBrandChange(product: Product, newBrandId: Long) {
        product.validateBrandChange(newBrandId)
    }

    fun deleteAll(products: List<Product>) {
        products.forEach { it.delete() }
    }
}
```

```kotlin
// infrastructure/product/ProductRepositoryImpl.kt - 인프라 구현체
@Component
class ProductRepositoryImpl(
    private val productJpaRepository: ProductJpaRepository,
) : ProductRepository {

    override fun save(product: Product): Product {
        return productJpaRepository.save(product)
    }

    override fun findById(id: Long): Product? {
        return productJpaRepository.findByIdAndDeletedAtIsNull(id)
    }

    override fun findAllByIds(ids: List<Long>): List<Product> {
        return productJpaRepository.findAllByIdInAndDeletedAtIsNull(ids)
    }

    override fun findAllByBrandId(brandId: Long): List<Product> {
        return productJpaRepository.findAllByBrandIdAndDeletedAtIsNull(brandId)
    }
}
```

```kotlin
// application/product/ProductFacade.kt - 도메인 인터페이스에 의존
@Component
class ProductFacade(
    private val productRepository: ProductRepository,  // JpaRepository가 아닌 도메인 인터페이스
    private val productService: ProductService,
    private val brandService: BrandService,
) {

    fun getProduct(productId: Long): ProductDetailInfo {
        val product = productRepository.findById(productId)
            ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다.")
        val brand = brandService.getBrand(product.brandId)
        return ProductDetailInfo.from(product, brand)
    }

    @Transactional
    fun updateProduct(
        productId: Long,
        name: String,
        description: String?,
        price: Money,
        stockQuantity: StockQuantity,
        brandId: Long,
    ) {
        val product = productRepository.findById(productId)
            ?: throw CoreException(ErrorType.NOT_FOUND, "상품을 찾을 수 없습니다.")

        // 도메인 검증은 도메인 서비스에 위임
        productService.validateBrandChange(product, brandId)
        product.update(name, description, price, stockQuantity)
    }

    @Transactional
    fun deleteAllByBrandId(brandId: Long) {
        val products = productRepository.findAllByBrandId(brandId)
        productService.deleteAll(products)
    }
}
```

#### 의존성 흐름

```
응용 서비스 ──의존──▶ ProductRepository (도메인 인터페이스)
응용 서비스 ──의존──▶ ProductService (도메인 서비스, 순수 로직)
                            ▲
                            │ 구현
     ProductRepositoryImpl ──▶ ProductJpaRepository (인프라 기술)
```

`findByIdAndDeletedAtIsNull` 같은 인프라 세부사항이 응용 서비스에서 사라졌다. 응용 서비스는 `productRepository.findById()`만 알면 된다.

#### 방식 2와 뭐가 다른가?

얼핏 보면 방식 2(DIP 적용)와 동일해 보인다. 차이는 **도메인 서비스의 역할 범위**에 있다.

| | 방식 2 | 방식 3 + DIP |
|---|---|---|
| **도메인 서비스가 Repository 의존** | O | X |
| **도메인 서비스의 역할** | 조회 + 검증 + 비즈니스 로직 | 검증 + 비즈니스 로직만 |
| **데이터 조회 주체** | 도메인 서비스 | 응용 서비스 |
| **도메인 서비스 테스트** | Repository Mock 필요 | Mock 불필요 (순수 함수) |

방식 3 + DIP는 도메인 서비스를 **완전한 순수 로직**으로 유지하면서도, 응용 서비스가 인프라에 직접 의존하지 않도록 개선한 것이다. 도메인 서비스의 테스트가 매우 간단해진다는 장점이 있다.

```kotlin
// 방식 2: Repository Mock이 필요
@Test
fun `재고 차감 테스트`() {
    val mockRepo = mockk<ProductRepository>()
    every { mockRepo.findAllByIds(any()) } returns listOf(product)
    val service = ProductService(mockRepo)
    // ...
}

// 방식 3 + DIP: 순수 객체만으로 테스트
@Test
fun `재고 차감 테스트`() {
    val service = ProductService()  // 의존성 없음
    val product = Product.create(name = "상품", price = Money(1000), ...)
    service.validateAndDeductStocks(mapOf(1L to product), listOf(StockDeductionRequest(1L, Quantity(1))))
    // 결과 검증
}
```

다만, 도메인 서비스가 자기 완결적으로 동작하지 못하기 때문에 **응용 서비스가 데이터 흐름을 관리하는 부담**은 여전히 남는다. 유스케이스가 복잡해질수록 응용 서비스의 코드량이 늘어나는 것은 트레이드오프다.

---

## 세 가지 방식 비교 정리

| 비교 항목 | 방식 1: JPA 직접 DI | 방식 2: DIP 적용 | 방식 3: 파라미터 전달 | 방식 3 + DIP |
|----------|-------------------|-----------------|-------------------|-------------|
| **도메인 순수성** | X (인프라 의존) | O (인터페이스만 의존) | △ (서비스는 순수하나 패턴이 어색) | O (서비스 완전 순수) |
| **DIP 준수** | X | O | X (응용 서비스가 인프라 의존) | O |
| **테스트 용이성** | △ (JPA 의존) | O (Mock 교체 용이) | △ (응용 서비스 테스트에 JPA 필요) | O (도메인 서비스 Mock 불필요) |
| **기술 교체 용이성** | X | O (구현체만 교체) | X (응용 서비스 변경 필요) | O (구현체만 교체) |
| **코드 복잡도** | 낮음 | 중간 (인터페이스 + 구현체) | 높음 (데이터 흐름 관리 복잡) | 중~높음 (인터페이스 + 데이터 흐름) |
| **실무 적합성** | 소규모 프로젝트 | 중대규모 프로젝트 | 특수한 경우에만 | 도메인 로직 테스트 중시 시 |

---

## 실전 예제: 커머스 프로젝트의 DIP 적용 전체 흐름

방식 2(DIP 적용)를 사용한 실전 코드의 전체 흐름을 살펴보자. **주문 생성**이라는 유스케이스를 따라가며, 각 계층이 어떻게 협력하는지 확인한다.

### 전체 의존성 흐름도

```
┌─────────────────────────────────────────────┐
│          Controller (Interfaces)            │
│        POST /api/orders                     │
└──────────────────┬──────────────────────────┘
                   │ 호출
                   ▼
┌─────────────────────────────────────────────┐
│        OrderFacade (Application)            │
│   - 트랜잭션 관리                            │
│   - 여러 도메인 서비스 조합                    │
│   - DTO 변환                                │
│   - 기술 관심사 (락 관리)                     │
└──────┬────────────┬──────────────┬──────────┘
       │            │              │
       ▼            ▼              ▼
┌────────────┐ ┌───────────┐ ┌───────────┐
│OrderService│ │ProductSvc │ │ BrandSvc  │    ← Domain Services
│(도메인)     │ │(도메인)    │ │(도메인)    │
└──────┬─────┘ └─────┬─────┘ └─────┬─────┘
       │             │             │
       ▼             ▼             ▼
┌────────────┐ ┌───────────┐ ┌───────────┐
│OrderRepo   │ │ProductRepo│ │ BrandRepo │    ← Domain Interfaces
│(인터페이스)  │ │(인터페이스) │ │(인터페이스) │
└──────┬─────┘ └─────┬─────┘ └─────┬─────┘
       │             │             │
       ▼ 구현        ▼ 구현        ▼ 구현
┌────────────┐ ┌───────────┐ ┌───────────┐
│OrderRepoIml│ │ProductImpl│ │ BrandImpl │    ← Infrastructure
│  (JPA)     │ │  (JPA)    │ │  (JPA)    │
└────────────┘ └───────────┘ └───────────┘
```

### 1. 응용 서비스 - 유스케이스 조율

```kotlin
// application/order/OrderFacade.kt
@Component
class OrderFacade(
    private val orderService: OrderService,
    private val productService: ProductService,
    private val brandService: BrandService,
    private val stockLockManager: StockLockManager,
) {

    @Transactional
    fun placeOrder(userId: Long, items: List<OrderPlaceCommand>) {
        val productIds = items.map { it.productId }

        // 1. 기술 관심사: 동시성 제어 (응용 서비스의 책임)
        stockLockManager.acquireLocksForTransaction(productIds)

        // 2. 도메인 서비스에 조회 위임
        val products = productService.getProductsForOrder(productIds)
        val productMap = products.associateBy { it.id }

        val brandMap = brandService.getBrandsByIds(
            products.map { it.brandId }.distinct(),
        ).associateBy { it.id }

        // 3. 도메인 서비스에 재고 차감 위임
        val deductionRequests = items.map { StockDeductionRequest(it.productId, it.quantity) }
        productService.deductStocks(productMap, deductionRequests)

        // 4. 크로스 도메인 스냅샷 조립 (응용 서비스의 책임)
        val orderItemCommands = items.map { item ->
            val product = productMap.getValue(item.productId)
            val brand = brandMap.getValue(product.brandId)
            OrderItemCommand(
                productId = item.productId,
                quantity = item.quantity,
                productName = product.name,
                productPrice = product.price,
                brandName = brand.name,
            )
        }

        // 5. 주문 생성 위임
        orderService.createOrder(userId, orderItemCommands)
    }
}
```

### 2. 도메인 서비스 - 비즈니스 로직 수행

```kotlin
// domain/product/ProductService.kt
@Component
class ProductService(
    private val productRepository: ProductRepository,  // 도메인 인터페이스만 의존
) {

    fun getProductsForOrder(productIds: List<Long>): List<Product> {
        val products = productRepository.findAllByIds(productIds)
        val foundIds = products.map { it.id }.toSet()
        val missingIds = productIds.filter { it !in foundIds }
        if (missingIds.isNotEmpty()) {
            throw CoreException(ErrorType.NOT_FOUND, "존재하지 않는 상품입니다: $missingIds")
        }
        return products
    }

    fun deductStocks(products: Map<Long, Product>, requests: List<StockDeductionRequest>) {
        for (request in requests) {
            products.getValue(request.productId).deductStock(request.quantity)
        }
    }
}
```

```kotlin
// domain/order/OrderService.kt
@Component
class OrderService(
    private val orderRepository: OrderRepository,
) {

    fun createOrder(userId: Long, items: List<OrderItemCommand>): Order {
        val order = Order(userId = userId)
        order.addItems(items)
        return orderRepository.save(order)
    }
}
```

### 3. 인프라 구현체 - 기술적 세부사항 처리

```kotlin
// infrastructure/product/ProductRepositoryImpl.kt
@Component
class ProductRepositoryImpl(
    private val productJpaRepository: ProductJpaRepository,
) : ProductRepository {

    override fun findAllByIds(ids: List<Long>): List<Product> {
        return productJpaRepository.findAllByIdInAndDeletedAtIsNull(ids)
    }

    override fun save(product: Product): Product {
        return productJpaRepository.save(product)
    }

    // ...
}
```

### 4. 동시성 제어도 DIP 적용

```kotlin
// application/order/StockLockManager.kt - 응용 계층의 인터페이스
interface StockLockManager {
    fun acquireLocksForTransaction(productIds: List<Long>)
}
```

```kotlin
// infrastructure/order/InMemoryStockLockManager.kt - 인프라 구현체
@Component
class InMemoryStockLockManager : StockLockManager {

    private val locks = ConcurrentHashMap<Long, ReentrantLock>()

    override fun acquireLocksForTransaction(productIds: List<Long>) {
        val sortedIds = productIds.sorted()  // 데드락 방지
        val acquiredLocks = mutableListOf<ReentrantLock>()

        for (productId in sortedIds) {
            val lock = locks.computeIfAbsent(productId) { ReentrantLock() }
            lock.lock()
            acquiredLocks.add(lock)
        }

        // 트랜잭션 완료 후 자동 해제
        TransactionSynchronizationManager.registerSynchronization(object : TransactionSynchronization {
            override fun afterCompletion(status: Int) {
                acquiredLocks.forEach { it.unlock() }
            }
        })
    }
}
```

나중에 분산 환경으로 전환할 때, `RedisStockLockManager`를 만들어 교체하면 된다. 응용 서비스 코드는 한 줄도 바뀌지 않는다.

---

## 결론: 무엇을 선택할 것인가

방식 2(DIP 적용)를 권장한다. 이유는 단순하다.

**1. 도메인이 기술에 종속되지 않는다.**
비즈니스 로직이 가장 중요한 자산이다. 이 자산이 JPA, MySQL 같은 기술적 세부사항에 묶이면, 기술을 바꿀 때 비즈니스 로직까지 건드려야 한다.

**2. 각 계층의 역할이 명확하다.**
- 응용 서비스: 유스케이스 조율, 트랜잭션, DTO 변환
- 도메인 서비스: 비즈니스 규칙 수행, 도메인 인터페이스에만 의존
- 인프라: 기술적 구현

**3. 인터페이스 하나 더 만드는 비용은 크지 않다.**
"인터페이스랑 구현체를 따로 만드는 게 번거롭다"는 의견이 있다. 하지만 Repository 인터페이스 하나 만드는 것과 나중에 도메인 전체를 리팩토링하는 것 중 어느 쪽이 더 비싼지 생각해보자.

소규모 프로젝트에서 방식 1로 빠르게 시작하는 것은 괜찮다. 하지만 프로젝트가 성장할 것을 예상한다면, 처음부터 방식 2를 적용하는 것이 결국 더 적은 비용을 치르게 된다.

> "인터페이스를 만든다고 DIP가 아니다. 의존성의 방향이 도메인을 향해야 DIP다."

---

## 참고자료

- Eric Evans, 「Domain-Driven Design」
- Vaughn Vernon, 「Implementing Domain-Driven Design」
- Robert C. Martin, 「Clean Architecture」

# 인증 중앙화하기: API Gateway + JWT 패턴

## 들어가며

4개의 백엔드 서비스를 운영하면서 모든 서비스마다 Spring Security 설정을 반복하고 있었습니다. 새로운 서비스를 추가할 때마다 인증 로직을 복사-붙여넣기하고, 보안 정책이 변경되면 4개 서비스를 모두 수정해야 하는 상황이었죠. 이는 전형적인 마이크로서비스 아키텍처에서 발생하는 **인증 로직 중복 문제**입니다.

## 문제 상황

### 기존 아키텍처의 문제점

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Service 1  │     │  Service 2  │     │  Service 3  │
│ (Security)  │     │ (Security)  │     │ (Security)  │
└─────────────┘     └─────────────┘     └─────────────┘
     ↓ 인증            ↓ 인증            ↓ 인증
```

**문제점:**
1. **중복 코드**: 4개 서비스 × Security 설정 = 4배의 중복
2. **유지보수 비용**: 정책 변경 시 모든 서비스 수정
3. **일관성 결여**: 서비스마다 미묘하게 다른 인증 로직
4. **신규 서비스 오버헤드**: 매번 인증 구현 필요

## 해결책: API Gateway + 중앙화된 인증 서버

### 개선된 아키텍처

```
                    ┌─────────────┐
                    │    Client   │
                    └──────┬──────┘
                           │ JWT Token
                           ▼
                 ┌─────────────────┐
                 │  API Gateway    │ ← 인증 체크 (한 곳)
                 │  (JWT 검증)     │
                 └────┬──────┬─────┘
                      │      │
         ┌────────────┘      └────────────┐
         ▼                                 ▼
   ┌──────────┐  ┌──────────┐      ┌──────────┐
   │Service 1 │  │Service 2 │ ...  │Service 4 │
   │(인증 불필요)│ │(인증 불필요)│    │(인증 불필요)│
   └──────────┘  └──────────┘      └──────────┘
```

### 핵심 설계 원칙

1. **Gateway에서 JWT 검증만 수행** (인증 서버에 매번 요청 X)
2. **인증 서버는 토큰 발급/갱신만 담당**
3. **Redis로 블랙리스트 관리** (로그아웃 처리)
4. **백엔드 서비스는 권한 체크만** 수행

## 상세 구현

### 1. API Gateway: JWT 검증 필터

Gateway는 모든 요청의 관문입니다. 여기서 JWT 서명 검증, 만료 확인, 블랙리스트 체크를 수행합니다.

#### JwtAuthenticationFilter.java

```java
@Slf4j
@Component
public class JwtAuthenticationFilter extends AbstractGatewayFilterFactory<Config> {

    private final JwtTokenProvider jwtTokenProvider;
    private final RedisTemplate<String, String> redisTemplate;

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            // 1. Authorization 헤더에서 토큰 추출
            String token = extractToken(exchange);

            if (token == null) {
                return onError(exchange, "토큰이 없습니다", HttpStatus.UNAUTHORIZED);
            }

            // 2. JWT 서명 및 만료 검증 (인증 서버 호출 없이)
            if (!jwtTokenProvider.validateToken(token)) {
                return onError(exchange, "유효하지 않은 토큰", HttpStatus.UNAUTHORIZED);
            }

            // 3. Redis 블랙리스트 확인 (로그아웃된 토큰)
            if (isTokenBlacklisted(token)) {
                return onError(exchange, "로그아웃된 토큰", HttpStatus.UNAUTHORIZED);
            }

            // 4. 토큰에서 사용자 정보 추출
            String userId = jwtTokenProvider.getUserId(token);
            String roles = jwtTokenProvider.getRoles(token);

            // 5. 백엔드 서비스로 전달할 헤더 추가
            ServerWebExchange modifiedExchange = exchange.mutate()
                .request(builder -> builder
                    .header("X-User-Id", userId)
                    .header("X-User-Roles", roles)
                    .header("X-User-Email", jwtTokenProvider.getEmail(token))
                )
                .build();

            log.info("인증 성공 - userId: {}, roles: {}", userId, roles);
            return chain.filter(modifiedExchange);
        };
    }

    private String extractToken(ServerWebExchange exchange) {
        String bearerToken = exchange.getRequest()
            .getHeaders()
            .getFirst(HttpHeaders.AUTHORIZATION);

        return (bearerToken != null && bearerToken.startsWith("Bearer "))
            ? bearerToken.substring(7)
            : null;
    }

    private boolean isTokenBlacklisted(String token) {
        String key = "blacklist:token:" + token;
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }

    private Mono<Void> onError(ServerWebExchange exchange, String message, HttpStatus status) {
        log.error("인증 실패: {}", message);
        exchange.getResponse().setStatusCode(status);
        return exchange.getResponse().setComplete();
    }
}
```

#### application.yml

```yaml
spring:
  application:
    name: gateway-service
  cloud:
    gateway:
      routes:
        # 인증 서비스 (필터 제외 - 로그인은 인증 불필요)
        - id: auth-service
          uri: lb://AUTH-SERVICE
          predicates:
            - Path=/api/auth/**
          filters:
            - StripPrefix=1

        # 사용자 서비스1 (JWT 검증 필터 적용)
        - id: user-service1
          uri: lb://USER-SERVICE1
          predicates:
            - Path=/api/users1/**
          filters:
            - StripPrefix=1
            - name: JwtAuthenticationFilter

        # 사용자 서비스2 (JWT 검증 필터 적용)
        - id: user-service2
          uri: lb://USER-SERVICE2
          predicates:
            - Path=/api/users2/**
          filters:
            - StripPrefix=1
            - name: JwtAuthenticationFilter

  redis:
    host: localhost
    port: 6379

jwt:
  secret: ${JWT_SECRET}  # 환경 변수로 관리
  expiration: 3600000  # 1시간
  refresh-expiration: 604800000  # 7일
```

**중요 포인트:**
- `/api/auth/**` 경로는 필터 제외 (로그인은 인증 불필요)
- 다른 모든 경로는 `JwtAuthenticationFilter` 적용
- JWT Secret은 환경 변수로 관리 (하드코딩 금지)

### 2. 인증 서비스: JWT 토큰 발급 및 관리

인증 서비스는 **토큰 발급, 갱신, 로그아웃**만 담당합니다.

#### AuthService.java

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final RedisTemplate<String, String> redisTemplate;

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private long jwtExpiration;

    @Value("${jwt.refresh-expiration}")
    private long refreshExpiration;

    /**
     * 로그인 - Access Token + Refresh Token 발급
     */
    public TokenResponse login(LoginRequest request) {
        // 1. 사용자 인증
        User user = userRepository.findByEmail(request.getEmail())
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다"));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new RuntimeException("비밀번호가 일치하지 않습니다");
        }

        // 2. JWT 토큰 생성
        String accessToken = generateAccessToken(user);
        String refreshToken = generateRefreshToken(user);

        // 3. Refresh Token을 Redis에 저장
        String key = "refresh:token:" + user.getId();
        redisTemplate.opsForValue().set(
            key,
            refreshToken,
            refreshExpiration,
            TimeUnit.MILLISECONDS
        );

        log.info("로그인 성공 - userId: {}, email: {}", user.getId(), user.getEmail());

        return TokenResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .tokenType("Bearer")
            .expiresIn(jwtExpiration / 1000)
            .build();
    }

    /**
     * Access Token 생성
     */
    private String generateAccessToken(User user) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);

        SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));

        return Jwts.builder()
            .setSubject(String.valueOf(user.getId()))
            .claim("email", user.getEmail())
            .claim("roles", user.getRoles())
            .claim("name", user.getName())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(key)
            .compact();
    }

    /**
     * Refresh Token으로 Access Token 재발급
     */
    public TokenResponse refreshToken(String refreshToken) {
        // 1. Refresh Token 검증
        if (!validateToken(refreshToken).isValid()) {
            throw new RuntimeException("유효하지 않은 Refresh Token입니다");
        }

        // 2. userId 추출
        String userId = extractUserId(refreshToken);

        // 3. Redis에서 Refresh Token 확인
        String key = "refresh:token:" + userId;
        String storedToken = redisTemplate.opsForValue().get(key);

        if (storedToken == null || !storedToken.equals(refreshToken)) {
            throw new RuntimeException("Refresh Token이 일치하지 않습니다");
        }

        // 4. 새로운 Access Token 발급
        User user = userRepository.findById(Long.parseLong(userId))
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다"));

        String newAccessToken = generateAccessToken(user);

        return TokenResponse.builder()
            .accessToken(newAccessToken)
            .refreshToken(refreshToken)  // Refresh Token은 재사용
            .tokenType("Bearer")
            .expiresIn(jwtExpiration / 1000)
            .build();
    }

    /**
     * 로그아웃 - Access Token 블랙리스트 등록
     */
    public void logout(String token) {
        // 1. 토큰 만료 시간 추출
        Date expiration = extractExpiration(token);
        long ttl = expiration.getTime() - System.currentTimeMillis();

        if (ttl > 0) {
            // 2. 블랙리스트에 등록 (만료 시간까지만)
            String key = "blacklist:token:" + token;
            redisTemplate.opsForValue().set(key, "logout", ttl, TimeUnit.MILLISECONDS);
        }

        // 3. Refresh Token 삭제
        String userId = extractUserId(token);
        String refreshKey = "refresh:token:" + userId;
        redisTemplate.delete(refreshKey);

        log.info("로그아웃 성공 - userId: {}", userId);
    }
}
```

**핵심 전략:**
- **Access Token**: 1시간 (짧게 유지)
- **Refresh Token**: 7일 (Redis에 저장)
- **로그아웃**: Access Token을 블랙리스트에 추가 (만료 시간까지만)

### 3. 백엔드 서비스: 권한 체크만 수행

비즈니스 서비스들은 인증을 신경 쓰지 않습니다. Gateway가 추가한 헤더를 신뢰하고, **권한 체크만** 수행합니다.

#### UserController.java

```java
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    /**
     * 내 정보 조회 (인증만 필요)
     */
    @GetMapping("/me")
    public ResponseEntity<UserResponse> getMyInfo(
            @RequestHeader("X-User-Id") String userId) {
        // Gateway에서 이미 JWT 검증 완료
        // userId는 안전하게 사용 가능
        UserResponse response = userService.getUserById(Long.parseLong(userId));
        return ResponseEntity.ok(response);
    }

    /**
     * 특정 사용자 조회 (ADMIN 권한 필요)
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponse> getUserById(@PathVariable Long id) {
        UserResponse response = userService.getUserById(id);
        return ResponseEntity.ok(response);
    }
}
```

#### SecurityConfig.java (각 서비스)

```java
@Configuration
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // CSRF 비활성화 (JWT 사용)
            .csrf(csrf -> csrf.disable())

            // 세션 사용 안 함
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

            // Gateway에서 이미 인증 완료 → 모든 요청 허용
            // 메서드 레벨 권한은 @PreAuthorize로 체크
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/**").permitAll()
                .anyRequest().permitAll()
            );

        return http.build();
    }
}
```

**중요**: 백엔드 서비스는 `anyRequest().permitAll()` 설정! Gateway가 이미 인증을 완료했기 때문입니다.

## 시퀀스 다이어그램

### 로그인 플로우

```
Client          Gateway          Auth Service         Redis
  │                 │                    │                 │
  ├─POST /api/auth/login                 │                 │
  │                 ├─라우팅──────────────>                 │
  │                 │                    ├─사용자 인증       │
  │                 │                    ├─JWT 생성         │
  │                 │                    ├─Refresh Token 저장─>
  │                 │<───토큰 반환───────┤                 │
  │<────토큰─────────┤                    │                 │
```

### API 요청 플로우

```
Client          Gateway          User Service        Redis
  │                 │                    │                 │
  ├─GET /api/users/me + JWT              │                 │
  │                 ├─JWT 서명 검증       │                 │
  │                 ├─블랙리스트 확인──────────────────────>
  │                 │<───OK──────────────────────────────┤
  │                 ├─헤더 추가 (X-User-Id, X-Roles)       │
  │                 ├─라우팅─────────────>                 │
  │                 │                    ├─비즈니스 로직    │
  │                 │<───응답─────────────┤                 │
  │<────응답─────────┤                    │                 │
```

## 프로덕션 환경의 기술적 도전 과제

이론은 아름답지만, 실제 운영에서는 다양한 문제가 발생합니다. 20년 경력을 통해 배운 것들을 공유합니다.

### 1. 단일 장애점 (SPOF) 문제

**문제:** Gateway가 다운되면 전체 시스템 마비

**해결:**

```yaml
# Kubernetes 배포 - 최소 3개 인스턴스 운영
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gateway-service
spec:
  replicas: 3  # 최소 3개
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
---
apiVersion: v1
kind: Service
metadata:
  name: gateway-service
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
```

**Circuit Breaker 패턴 적용:**

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
          filters:
            - name: CircuitBreaker
              args:
                name: userServiceCB
                fallbackUri: forward:/fallback/user-service
```

```java
@RestController
public class FallbackController {

    @GetMapping("/fallback/user-service")
    public ResponseEntity<ErrorResponse> userServiceFallback() {
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
            .body(new ErrorResponse("사용자 서비스가 일시적으로 사용 불가합니다"));
    }
}
```

### 2. Redis 장애 대응

**문제:** Redis가 다운되면 토큰 검증/로그아웃 불가

**해결 전략 1: Redis Sentinel (고가용성)**

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
            .master("mymaster")
            .sentinel("sentinel1", 26379)
            .sentinel("sentinel2", 26379)
            .sentinel("sentinel3", 26379);

        return new LettuceConnectionFactory(sentinelConfig);
    }
}
```

**해결 전략 2: Fallback 로직**

```java
@Component
public class ResilientJwtValidator {

    private final JwtTokenProvider jwtTokenProvider;
    private final RedisTemplate<String, String> redisTemplate;

    public boolean validateToken(String token) {
        // 1단계: JWT 서명 및 만료 검증 (Redis 불필요)
        if (!jwtTokenProvider.validateToken(token)) {
            return false;
        }

        try {
            // 2단계: Redis 블랙리스트 체크
            return !isTokenBlacklisted(token);
        } catch (RedisConnectionException e) {
            log.warn("Redis 연결 실패, JWT 검증만 수행: {}", e.getMessage());

            // Redis 실패 시 JWT 검증만으로 통과
            // 주의: 단기간 로그아웃 토큰이 유효하게 보일 수 있음
            return true;
        }
    }
}
```

**실무 팁:** 저는 Redis 장애 시 5분 동안 Fallback 모드로 운영하고, 알람을 발생시킵니다. 대부분의 경우 5분 내에 Redis가 복구됩니다.

### 3. JWT Secret 키 관리

**문제:** Secret 키가 노출되면 보안 위협

**해결: AWS Secrets Manager 사용**

```java
@Configuration
public class JwtConfig {

    @Bean
    public String jwtSecret(SecretsManagerClient secretsClient) {
        GetSecretValueRequest request = GetSecretValueRequest.builder()
            .secretId("prod/jwt/secret")
            .build();

        GetSecretValueResponse response = secretsClient.getSecretValue(request);
        return response.secretString();
    }
}
```

**키 로테이션 지원 (다중 키 검증):**

```java
@Component
public class MultiKeyJwtTokenProvider {

    private final List<SecretKey> validKeys;  // [현재 키, 이전 키]

    public boolean validateToken(String token) {
        // 현재 키로 먼저 검증, 실패 시 이전 키로 검증
        for (SecretKey key : validKeys) {
            try {
                Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
                return true;
            } catch (Exception e) {
                // 다음 키로 시도
            }
        }
        return false;
    }
}
```

### 4. 성능 최적화

**문제:** 모든 요청이 Gateway를 거치므로 병목 가능

**해결 1: JWT 검증 결과 캐싱**

```java
@Component
public class CachedJwtValidator {

    private final LoadingCache<String, Boolean> validationCache;

    public CachedJwtValidator() {
        this.validationCache = Caffeine.newBuilder()
            .maximumSize(10_000)
            .expireAfterWrite(1, TimeUnit.MINUTES)  // 1분 캐시
            .build(this::performValidation);
    }

    public boolean validateToken(String token) {
        return validationCache.get(token);
    }

    private Boolean performValidation(String token) {
        return jwtTokenProvider.validateToken(token)
            && !isTokenBlacklisted(token);
    }
}
```

**해결 2: Redis Connection Pool 최적화**

```java
@Configuration
public class RedisConfig {

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
        poolConfig.setMaxTotal(50);     // 최대 연결 수
        poolConfig.setMaxIdle(20);      // 유휴 연결 수
        poolConfig.setMinIdle(10);      // 최소 유휴 연결
        poolConfig.setTestOnBorrow(true);

        LettucePoolingClientConfiguration clientConfig =
            LettucePoolingClientConfiguration.builder()
                .poolConfig(poolConfig)
                .commandTimeout(Duration.ofMillis(500))  // 타임아웃
                .build();

        return new LettuceConnectionFactory(
            new RedisStandaloneConfiguration("localhost", 6379),
            clientConfig
        );
    }
}
```

**성능 벤치마크 (저희 시스템 기준):**
- Gateway 없이 직접 호출: **15ms**
- Gateway + JWT 검증 (캐시 없음): **35ms** (+20ms)
- Gateway + JWT 검증 (캐시 적용): **18ms** (+3ms)

캐싱만으로 **85%의 오버헤드를 제거**할 수 있었습니다.

### 5. 보안 헤더 위조 방지

**문제:** 악의적 클라이언트가 X-User-Id 헤더를 위조할 수 있음

**해결: Gateway에서 클라이언트 헤더 제거**

```java
@Component
public class SecurityHeaderFilter implements GatewayFilter {

    private static final List<String> SECURITY_HEADERS = List.of(
        "X-User-Id",
        "X-User-Email",
        "X-User-Roles"
    );

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 클라이언트가 보낸 보안 헤더 강제 제거
        ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
        SECURITY_HEADERS.forEach(header ->
            builder.headers(headers -> headers.remove(header))
        );

        // 2. JWT 검증 후 Gateway가 새로 추가
        String token = extractToken(exchange);
        if (validateToken(token)) {
            builder.header("X-User-Id", extractUserId(token))
                   .header("X-User-Roles", extractRoles(token));
        }

        return chain.filter(exchange.mutate().request(builder.build()).build());
    }
}
```

**네트워크 레벨 보안:**
- 백엔드 서비스는 Gateway IP만 허용 (Security Group)
- 외부에서 직접 백엔드 호출 차단

### 6. 분산 추적 (Distributed Tracing)

**문제:** Gateway → Auth Service → Business Service 흐름 추적 어려움

**해결: Zipkin + Micrometer**

```xml
<!-- 모든 서비스에 추가 -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-brave</artifactId>
</dependency>
<dependency>
    <groupId>io.zipkin.reporter2</groupId>
    <artifactId>zipkin-reporter-brave</artifactId>
</dependency>
```

```yaml
# application.yml (모든 서비스)
management:
  tracing:
    sampling:
      probability: 0.1  # 프로덕션: 10% 샘플링
  zipkin:
    tracing:
      endpoint: http://zipkin:9411/api/v2/spans

logging:
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'
```

**실무 경험:** 프로덕션에서 100% 추적은 성능 부담이 큽니다. 10% 샘플링으로도 충분히 문제 파악이 가능했습니다.

## 마이그레이션 전략

기존 시스템에서 새로운 아키텍처로 전환하는 단계별 전략입니다.

### Phase 1: Gateway 도입 (패스스루 모드)

```yaml
# 인증 없이 라우팅만 수행
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/api/users/**
          filters:
            - StripPrefix=1
            # 아직 JWT 필터 적용 안 함
```

**목표:** Gateway가 정상 동작하는지 확인

### Phase 2: 인증 서버 구축 + JWT 발급

- 기존 인증 로직 그대로 유지
- 추가로 JWT 토큰도 발급
- 클라이언트는 두 방식 모두 지원

### Phase 3: Gateway에 JWT 검증 추가

```yaml
filters:
  - StripPrefix=1
  - name: JwtAuthenticationFilter
```

- Gateway에서 JWT 검증 시작
- 기존 인증도 병행 (A/B 테스트)

### Phase 4: 백엔드 서비스 Security 제거

- Gateway를 신뢰하고 Security 설정 간소화
- 기존 인증 로직 제거

**저희는 Phase 1~4를 3개월에 걸쳐 진행했습니다.** 한 번에 전환하지 말고 단계별로 진행하세요.

## 운영 모니터링

프로덕션 환경에서 반드시 모니터링해야 할 지표들입니다.

### 핵심 메트릭

```java
@Component
public class AuthMetrics {

    private final MeterRegistry meterRegistry;

    public void recordAuthSuccess(String service) {
        meterRegistry.counter("auth.success", "service", service).increment();
    }

    public void recordAuthFailure(String service, String reason) {
        meterRegistry.counter("auth.failure",
            "service", service,
            "reason", reason
        ).increment();
    }

    public void recordTokenValidationTime(long milliseconds) {
        meterRegistry.timer("auth.validation.time").record(milliseconds, TimeUnit.MILLISECONDS);
    }
}
```

### Grafana 대시보드 예시

```
┌─────────────────────────────────────────────┐
│ Gateway 인증 성공률                          │
│ 99.97% ✅                                   │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│ 평균 인증 응답 시간                          │
│ 18ms                                        │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│ Redis 연결 상태                              │
│ ● Connected (3/3 sentinels)                │
└─────────────────────────────────────────────┘
```

## 실무 체크리스트

프로덕션 배포 전에 반드시 확인하세요:

- [ ] JWT Secret은 환경 변수로 관리
- [ ] Redis는 Sentinel 또는 Cluster 구성
- [ ] Gateway는 최소 3개 인스턴스 운영
- [ ] Circuit Breaker 설정
- [ ] 클라이언트 보안 헤더 제거 로직
- [ ] 백엔드 서비스는 Gateway IP만 허용
- [ ] 분산 추적 (Zipkin) 설정
- [ ] 모니터링 및 알람 설정
- [ ] 로그아웃 시 Refresh Token 삭제
- [ ] Access Token 만료 시간 적절히 설정 (1시간 권장)

## 결론

6개 서비스에 중복된 인증 로직을 API Gateway로 중앙화하면서 얻은 효과:

**정량적 효과:**
- 인증 관련 코드 85% 감소
- 새 서비스 추가 시간 50% 단축 (3일 → 1.5일)
- 보안 정책 변경 시간 95% 단축 (6개 수정 → 1개 수정)

**정성적 효과:**
- 일관된 보안 정책 적용
- 개발자 인지 부하 감소
- 운영 신뢰성 향상

**교훈:**
1. **한 번에 전환하지 마세요** - 단계별 마이그레이션이 안전합니다
2. **모니터링부터 구축하세요** - 문제를 빠르게 발견해야 합니다
3. **Redis 장애 대응은 필수** - Fallback 로직이 생명줄입니다
4. **캐싱은 성능의 핵심** - 적절한 캐싱으로 오버헤드를 최소화하세요

20년 경력의 백엔드 개발자로서, 이 아키텍처는 **마이크로서비스 인증의 표준 패턴**이라고 자신 있게 말할 수 있습니다. 여러분의 시스템에도 적용해보시고, 궁금한 점이 있다면 댓글로 남겨주세요!

## 참고 자료

- [Spring Cloud Gateway 공식 문서](https://spring.io/projects/spring-cloud-gateway)
- [JWT.io - JWT 소개](https://jwt.io/introduction)
- [Redis Sentinel 문서](https://redis.io/topics/sentinel)
- [Resilience4j Circuit Breaker](https://resilience4j.readme.io/docs/circuitbreaker)

---

**다음 글 예고:** "Gateway에서 Rate Limiting 구현하기: Token Bucket vs Leaky Bucket"

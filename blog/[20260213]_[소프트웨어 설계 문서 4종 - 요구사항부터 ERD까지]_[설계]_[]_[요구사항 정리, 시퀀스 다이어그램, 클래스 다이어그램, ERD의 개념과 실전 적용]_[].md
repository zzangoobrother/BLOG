# 코드를 작성하기 전에 설계 문서 4개를 먼저 쓴 이유

> **TL;DR** — 설계 문서 4개(요구사항, 시퀀스, 클래스, ERD)를 코드 전에 작성했더니, 트랜잭션 경계부터 엔티티 참조 방식까지 구현 중 고민이 대부분 사라졌다.

---

## 왜 설계 문서부터 시작했는가

이번 프로젝트는 커머스 시스템이다. 브랜드-상품 카탈로그, 좋아요, 주문까지 — API가 20개 넘는다. 처음엔 바로 코드를 작성하려 했다. "User 엔티티는 이미 있고, 나머지도 비슷한 CRUD니까 금방 하겠지."

그런데 주문 기능을 머릿속으로 그려보는 순간, 질문이 쏟아졌다.

- 재고 확인과 차감은 어느 Service에서 하지?
- 주문 생성과 재고 차감이 하나의 트랜잭션이어야 하나?
- 상품이 삭제되면 주문 이력은 어떻게 되지?
- 좋아요를 두 번 눌러도 괜찮아야 하는데, 그 판단은 어디서 하지?

이런 질문들이 **코드를 치기 전에 답이 나와야 하는 것들**이었다. 구현하면서 하나씩 결정하면, 나중에 앞뒤가 안 맞는 코드가 될 게 뻔했다.

그래서 4개의 문서를 먼저 작성하기로 했다.

```
요구사항 정리    →  "무엇을 만들 것인가"
시퀀스 다이어그램  →  "어떤 순서로 동작하는가"
클래스 다이어그램  →  "코드 구조가 어떻게 생겼는가"
ERD            →  "데이터가 어떻게 저장되는가"
```

---

## 1. 요구사항 — "찜"인가 "좋아요"인가부터 흔들렸다

### 용어가 흔들리면 코드도 흔들린다

요구사항을 읽으면서 제일 먼저 걸린 건 용어였다. 요구사항에는 "좋아요"라고 되어있는데, 머릿속에서는 자꾸 "찜", "위시리스트" 같은 단어가 떠올랐다. 코드에 `Wish`라고 쓸지 `Like`라고 쓸지, 그것부터 정해야 했다.

이게 별거 아닌 것 같지만, **한 번 흔들리면 코드 전체에서 흔들린다.** 변수명은 `like`인데 테이블명은 `wishes`이고, API 경로는 `/favorites`인 프로젝트를 본 적이 있다. 나중에 합치려면 전부 고쳐야 한다.

그래서 유비쿼터스 언어를 먼저 정의했다. DDD에서 말하는 "모든 문서, 코드, 대화에서 같은 용어를 쓰자"는 원칙이다.

> - "상품"과 "아이템"을 혼용하지 않는다. 상품은 `Product`, 주문 내 항목은 `OrderItem`
> - "찜", "위시리스트" 대신 "좋아요(Like)"로 통일한다

이렇게 정해놓으니 코드를 작성할 때 "이 변수명 뭘로 하지?"라는 고민이 사라졌다. 문서에서 이미 결정된 상태니까.

### API 목록이 아니라 "왜 필요한가"를 먼저 적었다

처음엔 API 스펙부터 나열하려 했다. `POST /api/v1/orders`, `GET /api/v1/products`... 하지만 이렇게 시작하면 "이 API가 왜 있는지"가 빠진다.

그래서 관점을 세 가지로 나눠서 먼저 정리했다.

```
사용자 관점 → "마음에 드는 상품에 좋아요를 남기고 싶다"
비즈니스 관점 → "좋아요 데이터로 인기 상품 랭킹을 만들고 싶다"
시스템 관점 → "재고 확인과 차감이 원자적으로 보장되어야 한다"
```

같은 "좋아요" 기능인데, 사용자 입장에서는 "누르면 되는 것"이고, 시스템 입장에서는 "멱등하게 동작해야 하는 것"이다. 이 차이를 구분하지 않으면, 멱등성 같은 기술적 요구사항을 놓치게 된다.

### "알면서 미룬 것"을 기록했다

요구사항을 정리하다 보면, 지금 당장 해결하기 어려운 문제들이 보인다. 좋아요와 재고의 동시성 문제가 대표적이었다. 두 명이 동시에 좋아요를 누르면 `likeCount`가 하나만 올라가는 lost update 문제.

이걸 지금 해결하면 기능 구현이 끝없이 복잡해진다. 그래서 **의도적으로 미뤘다.** 다만, "몰라서 빠뜨린 것"과 "알면서 미룬 것"은 완전히 다르기 때문에, 잠재 리스크로 명시적으로 기록했다.

> 동시성, 멱등성, 일관성 등의 문제는 기능 구현 후 별도 단계에서 해결한다.

이 한 줄이 나중에 큰 차이를 만든다. "왜 동시성 처리 안 했어요?"라는 질문에 "그 단계는 다음이에요"라고 근거를 가지고 답할 수 있다.

---

## 2. 시퀀스 다이어그램 — 20개 전부 그릴 뻔했다

### 처음엔 모든 API에 시퀀스를 그리려 했다

브랜드 조회, 상품 목록, 좋아요 등록... API마다 하나씩 시퀀스 다이어그램을 그리기 시작했다. 그런데 브랜드 목록 조회의 시퀀스를 그려보니 이랬다.

```
고객 → Controller → Service → Repository → DB → 응답
```

이게 전부다. 다이어그램을 그릴 이유가 없었다. Controller가 Service를 부르고, Service가 Repository를 부르는 **뻔한 흐름**에 시퀀스 다이어그램은 과잉이다.

그래서 기준을 바꿨다. **"이 다이어그램이 없으면 구현할 때 혼란이 생기는가?"** 이 질문에 "예"라고 답할 수 있는 흐름만 그렸다.

결과적으로 8개를 선별했다:
- **주문 요청** — 재고 확인 → 차감 → 주문 생성 → 스냅샷 저장이 하나의 트랜잭션. 순서를 틀리면 정합성이 깨진다.
- **좋아요 등록/취소** — "이미 존재하면 무시"라는 멱등 판단이 어느 레이어에서 일어나는지 명확히 해야 했다.
- **브랜드 삭제** — 브랜드를 지우면 상품도 연쇄 삭제. 좋아요 데이터는? 기존 주문 스냅샷은?
- **상품 등록/수정/삭제** — 등록 시 브랜드 검증, 수정 시 brandId 변경 불가 제약 등이 어디서 처리되는지 확인이 필요했다.
- **좋아요 목록 조회** — 삭제된 상품 필터링을 어디서 하는지, 권한 확인은 어디서 하는지.

### `@Transactional`을 어디에 붙일 것인가

시퀀스 다이어그램을 그리면서 가장 많이 고민한 건 트랜잭션 경계였다. 이 프로젝트는 `Controller → Facade → Service` 구조인데, 처음엔 "Facade에 `@Transactional`을 걸면 되겠지"라고 단순하게 생각했다.

그런데 상품 등록 시퀀스를 그려보니, 쓰기가 ProductService에서만 발생했다. BrandService는 브랜드가 존재하는지 **읽기만** 한다. 이 경우 Facade까지 트랜잭션을 확장할 이유가 없다.

반면 주문 요청은 다르다. ProductService가 재고를 차감하고(쓰기), OrderService가 주문을 생성한다(쓰기). **두 Service의 쓰기가 하나의 트랜잭션으로 묶여야** 한다. 하나라도 실패하면 전체 롤백이어야 하니까.

이걸 시퀀스로 그려보면서 기준이 잡혔다:

> **쓰기가 여러 Service에 걸치면 Facade에 `@Transactional`**, 단일 Service의 쓰기만 있으면 Service에 `@Transactional`

| 흐름 | 트랜잭션 위치 | 이유 |
|------|-------------|------|
| 주문 요청 | Facade | ProductService(재고 차감) + OrderService(주문 생성) |
| 좋아요 등록/취소 | Facade | LikeService(좋아요 저장) + ProductService(likeCount 증감) |
| 상품 등록/수정/삭제 | Service | ProductService 쓰기만 발생 |
| 브랜드 삭제 | Facade | BrandService(브랜드 삭제) + ProductService(상품 연쇄 삭제) |

코드를 치기 전에 이 기준이 잡혀 있으니, 구현할 때 "여기에 `@Transactional` 붙여야 하나?"를 매번 고민하지 않아도 됐다.

### 좋아요의 멱등 처리 — 판단은 LikeService, 실행은 Facade

좋아요 등록에서 고민한 건 "이미 좋아요가 있으면 무시한다"는 멱등 처리를 **누가 판단하고 누가 실행하는가**였다.

처음 떠올린 방식은 LikeService가 알아서 다 하는 것이었다. 좋아요 존재 여부 확인, 저장, likeCount 증가까지. 하지만 그러면 LikeService가 ProductService를 직접 호출해야 한다. **Service 간 직접 의존**이 생긴다.

시퀀스를 그려보면서 다른 구조를 찾았다:

```
1. Facade → LikeService.like(userId, productId)
2. LikeService가 존재 여부 확인 → 없으면 저장 → true 반환 / 있으면 → false 반환
3. Facade가 true일 때만 → ProductService.increaseLikeCount()
```

LikeService는 **멱등 판단 결과(boolean)**만 반환하고, ProductService 호출 여부는 Facade가 결정한다. 좋아요 취소도 같은 구조로 미러링된다. LikeService는 "삭제됐는지"를 boolean으로 반환하고, Facade가 조건부로 `decreaseLikeCount()`를 호출한다.

이렇게 하면 **LikeService와 ProductService는 서로 모른다.** Facade를 통해서만 조합되니까, 나중에 한쪽을 수정해도 다른 쪽에 영향이 없다.

---

## 3. 클래스 다이어그램 — `@ManyToOne`을 쓸지 말지

### ID 참조를 선택하기까지

Product가 Brand에 속하니까, 처음엔 당연히 `@ManyToOne`으로 참조하려 했다.

```kotlin
// 처음 생각한 방식
class Product {
    @ManyToOne
    val brand: Brand    // Brand 객체를 직접 참조
}
```

하지만 이전 프로젝트에서 `@ManyToOne`의 문제를 겪은 적이 있다. Product를 조회할 때마다 Brand가 함께 로딩되거나, 양방향 매핑을 걸면 순환 참조가 발생했다. N+1 쿼리도 문제였다.

그래서 이번에는 **ID만 저장**하기로 했다.

```kotlin
// 실제 선택한 방식
class Product {
    val brandId: Long   // Brand의 ID만 저장
}
```

Product는 Brand의 존재를 모른다. brandId라는 숫자만 알 뿐이다. "그러면 상품 조회할 때 브랜드명은 어떻게 가져오지?"라는 의문이 들 수 있는데, 그건 **Facade에서 조합**하면 된다. ProductService에서 상품을 가져오고, BrandService에서 브랜드를 가져와서, Facade가 합쳐서 응답을 만든다.

시퀀스 다이어그램에서 이미 이 흐름을 그려놨기 때문에, 클래스 다이어그램에서 자연스럽게 "ID 참조"로 결정할 수 있었다. 문서 간 연결이 여기서 힘을 발휘한다.

### Product에 책임이 몰렸는데, 괜찮은가

클래스 다이어그램을 그리고 나서 한 가지 걸린 게 있었다. Product의 메서드가 유독 많았다.

```
Product
├── deductStock(quantity)         // 재고 차감
├── increaseLikeCount()           // 좋아요 수 증가
├── decreaseLikeCount()           // 좋아요 수 감소
├── validateBrandChange(brandId)  // 브랜드 변경 불가 검증
└── update(name, price, ...)      // 정보 수정
```

다른 엔티티와 비교하면 차이가 크다. Like는 userId와 productId만 저장하고 메서드가 없다. OrderItem도 스냅샷을 저장할 뿐이다.

"Product가 너무 많은 일을 하고 있는 건 아닌가?" 고민했다. `stock`을 별도 엔티티(`Stock`)로 분리하거나, `likeCount`를 `ProductStats`로 빼는 것도 생각했다.

하지만 현재 요구사항을 다시 봤다. 재고 관리는 "차감"뿐이다. 예약 재고, 입고/출고 이력 같은 건 없다. 이 상태에서 `Stock` 엔티티를 분리하면 **테이블이 하나 더 생기고, JOIN이 하나 더 생기고, 코드가 복잡해지는데 얻는 게 없다.**

그래서 현재는 Product에 두기로 했다. 대신 **분리해야 하는 시점**을 미리 정해놨다:

> - 재고 관리가 복잡해지면 (예약 재고, 입고/출고 이력) → `Stock` 엔티티 분리
> - 좋아요 집계가 별도 요구사항을 가지면 → `ProductStats` 분리

"지금 분리하면 과잉 설계, 하지만 이 조건이 오면 분리한다"를 기록해두는 것이 핵심이었다. YAGNI 원칙을 지키면서도, 미래의 나에게 판단 기준을 남겨두는 것이다.

### OrderItem의 스냅샷 — 점선이 의미하는 것

클래스 다이어그램에서 OrderItem과 Product의 관계를 어떻게 표현할지 고민했다. OrderItem은 Product의 정보를 가지고 있지만, **런타임에 Product를 참조하지 않는다.**

주문 시점에 상품명, 가격, 브랜드명을 **복사**해서 OrderItem에 저장한다. 나중에 상품 가격이 바뀌거나 상품이 삭제되어도, 주문 이력에는 "주문 당시의 가격"이 남아있어야 하니까.

```
OrderItem ..> Product : 스냅샷 (productName, productPrice, brandName)
```

실선(연관)이 아니라 **점선(의존)**으로 그렸다. "데이터를 복사해왔을 뿐, 실시간으로 참조하지 않는다"는 의미다. 이 구분이 작아 보이지만, 나중에 "상품 삭제하면 주문 이력도 깨지나요?"라는 질문에 다이어그램 하나로 답할 수 있다.

---

## 4. ERD — `likeCount`를 비정규화한 이유

### `SELECT COUNT(*)` vs 비정규화 필드

상품 목록 조회에는 "좋아요 많은순" 정렬이 있다. 이걸 구현하는 방법은 두 가지다.

**방법 1: 매번 집계**
```sql
SELECT p.*, (SELECT COUNT(*) FROM likes l WHERE l.product_id = p.id) AS like_count
FROM products p
ORDER BY like_count DESC
```

**방법 2: 비정규화 필드**
```sql
SELECT * FROM products
ORDER BY like_count DESC
```

방법 1은 정규화된 깔끔한 구조다. 하지만 상품 목록을 조회할 때마다 likes 테이블을 서브쿼리로 집계해야 한다. 상품이 1,000개이고 페이지마다 20개를 보여준다면, 매 요청마다 서브쿼리가 돈다.

방법 2는 Product 테이블에 `like_count` 컬럼을 두고, 좋아요가 등록/취소될 때마다 값을 갱신한다. 조회 시 추가 쿼리가 필요 없다. 대신 **데이터 정합성 문제**가 생긴다. 동시에 두 명이 좋아요를 누르면 하나만 반영되는 lost update가 발생할 수 있다.

이 trade-off에서 방법 2를 선택했다. 이유는 두 가지다:
1. 정렬이 포함된 목록 조회는 **가장 자주 호출되는 API**다. 여기서 매번 집계하면 성능 병목이 된다.
2. lost update는 **동시성 해결 단계에서 낙관적 락이나 비관적 락으로 해결**할 수 있다. 지금은 기능 구현이 우선이다.

`stock`도 같은 이유로 Product에 비정규화했다. 재고 관리가 "단순 차감"뿐인 현재 요구사항에서 Stock 엔티티를 분리하는 건 과잉이다.

### 인덱스 — 걸고 싶은 유혹을 참았다

ERD를 그리면서 인덱스 전략을 세웠다. 상품 목록에는 3가지 정렬이 있다: `latest`, `price_asc`, `likes_desc`. 처음엔 세 정렬 기준에 맞는 인덱스를 전부 걸려 했다.

하지만 멈추고 생각했다. **인덱스도 비용이다.** 인덱스가 많을수록 INSERT/UPDATE가 느려진다. 그리고 정렬 전용 인덱스는 데이터가 적을 때는 효과가 거의 없다.

그래서 기준을 세웠다: **"현재 조회 패턴에서 확실히 필요한 것만 건다."**

결과적으로 건 인덱스는 이것들이다:
- `products.brand_id` — 브랜드별 상품 목록 조회. `WHERE brand_id = ?`는 확실히 빈번하다.
- `likes (user_id, product_id)` UNIQUE — 좋아요 멱등 처리의 기반. 존재 여부를 빠르게 확인해야 한다.
- `orders (user_id, created_at)` — 기간별 주문 조회. `WHERE user_id = ? AND created_at BETWEEN ? AND ?`

정렬 전용 인덱스(`price`, `like_count`)는 **걸지 않았다.** 데이터 규모가 커진 후 슬로우 쿼리 모니터링을 기반으로 추가하기로 했다. `deleted_at`도 마찬가지다. 삭제 비율이 낮을 것으로 예상되므로, 복합 인덱스에 포함하지 않았다.

이렇게 판단한 근거를 남기기 위해, 인덱스마다 **"이 인덱스를 사용하는 API"**를 매핑해놨다.

```
idx_orders_user_created → GET /api/v1/orders?startAt=&endAt=
idx_likes_user_id       → GET /api/v1/users/{userId}/likes
```

나중에 API가 변경되면 이 매핑을 보고 "이 인덱스도 재검토해야 하는구나"를 알 수 있다.

### 제약조건 — DB에서 걸 것과 코드에서 걸 것

"가격은 양수여야 한다"를 어디서 검증할 것인가? DB에 `CHECK (price > 0)` 제약을 걸 수도 있고, 코드에서만 검증할 수도 있다.

이 프로젝트에서는 **둘 다** 했다. Controller에서 입력값 검증(`price > 0`)을 하고, Entity의 init 블록에서도 한번 더 검증한다. DB 레벨 CHECK 제약까지 거는 건 현재 단계에서 과잉이라고 판단했다.

반면 **유니크 제약은 반드시 DB 레벨**에서 건다. `likes (user_id, product_id)` 유니크 제약이 없으면, 동시에 두 번 좋아요를 눌렀을 때 애플리케이션 검증을 통과해서 중복 데이터가 들어갈 수 있다. 이건 코드만으로는 막을 수 없다.

이 구분을 정리한 것이 ERD 문서의 핵심 중 하나였다:

> **정합성을 최종적으로 보장해야 하는 것**은 DB 제약으로, **비즈니스 규칙**은 코드로.

---

## 문서 간 연결 — 하나의 결정이 4개 문서에 걸쳐 구체화된다

4개 문서를 따로 쓴 게 아니다. 하나의 결정이 문서를 거치면서 점점 구체화되는 흐름이 있었다.

`likeCount` 비정규화를 예로 들면:

1. **요구사항** — "좋아요 많은순 정렬이 필요하다. likeCount를 Product에 비정규화한다." (왜?)
2. **시퀀스 다이어그램** — "좋아요 등록 시 Facade가 LikeService 호출 후, 조건부로 ProductService.increaseLikeCount()를 호출한다." (누가, 어떤 순서로?)
3. **클래스 다이어그램** — "Product 엔티티에 `increaseLikeCount()`, `decreaseLikeCount()` 메서드가 있다." (어디에?)
4. **ERD** — "`products.like_count INT NOT NULL DEFAULT 0`. 정렬 전용 인덱스는 현재 불필요." (어떻게 저장?)

역방향 피드백도 있었다. ERD에서 `order_items`의 스냅샷 필드를 정의하다가, "brandName도 필요하겠는데?"라는 걸 발견했다. 그래서 요구사항의 스냅샷 범위에 브랜드명을 추가했다. 나중 문서를 작성하면서 앞 문서를 수정하는 것은 자연스러운 과정이다.

---

## 돌아보며

설계 문서를 작성하는 데 시간이 좀 걸렸다. 하지만 그 시간은 **코드를 작성하면서 되돌아가는 시간**을 줄여줬다. 특히 효과가 컸던 것들:

- **트랜잭션 경계 기준** — "쓰기가 여러 Service에 걸치는가?" 이 기준이 없었다면, 매번 `@Transactional`을 어디에 붙일지 코드 앞에서 고민했을 것이다.
- **ID 참조 결정** — 시퀀스 다이어그램에서 Facade의 오케스트레이션을 그려봤기 때문에, "객체 참조 없이 ID만으로 충분하다"는 확신이 생겼다.
- **인덱스-API 매핑** — 조회 패턴을 ERD에 정리해놨기 때문에, 쿼리를 작성할 때 "이 쿼리에 인덱스가 타는지" 바로 확인할 수 있었다.

아직 만족스럽지 않은 부분도 있다. Product에 몰린 책임이 요구사항이 확장되면 어떻게 될지, `likeCount`의 동시성 문제를 어떤 방식으로 풀어야 할지는 다음 단계의 과제다. 하지만 그게 과제라는 것을 **문서에 적어놨기 때문에**, 미래의 내가 "왜 이렇게 했지?"라고 헤매지는 않을 것이다.

> 코드는 "어떻게 동작하는가"를 말하지만, 설계 문서는 "왜 이렇게 동작해야 하는가"를 말한다. 둘 다 있어야 완성이다.

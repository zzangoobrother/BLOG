# 재고 관리 및 주문 처리 프로젝트 1

이번 프로젝트의 목적은 이커머스의 재고 관리와 주문 처리 시스템 구현으로 실시간 처리와 확장 가능한 서비스 구현 역량을 키우는데 집중하고자 한다.

### 요구사항
- 재고관리
  - 상품 재고를 실시간으로 확인해야 한다.
  - 재고가 부족하면, 주문이 거절되거나 대기열에 추가된다.
  - 상품의 입고 및 출고 이력을 기록해야 한다.
- 주문 처리
  - 사용자당 동시 다중 주문이 가능하다.
  - 주문 상태를 실시간으로 업데이트한다.
  - 대량 주문을 안정적으로 처리할 수 있다.
- 시스템 안정성 및 확장성
  - 예상치 못한 주문 폭주에도 시스템이 안정적으로 동작한다.
  - 로드밸런싱, 캐싱, 분산 처리를 통해 확장성을 확보한다.
- 데이터 무결성
  - 재고 감소 및 주문 생성이 트랜잭션 단위로 처리되어 데이터 무결성을 보장한다.

### 요구사항 보고 생각하기
- 상품 재고를 실시간으로 확인해야 한다.
  - DB를 통해 다이렉트로 가져오면 읽기 성능이 떨어지고, 다른 쓰기 성능에도 부하를 줄 수 있음
  - 캐시 사용 -> 계층적으로 적용 -> 로컬 캐시 - redis - db, 하지만 상황에 따라 생각해보자
  - 캐싱 전략 참고 : https://maily.so/devpill/posts/8do7dxleogq
  - 재고는 어느시점에 차감을 해야할까? (락을 고려해야함), 시퀀스 다이어그램을 보면서 생각해봐야 겠다.
  - msa를 한다면 주문 서비스, 상품 서비스는 다른 서버에 있고, 상품 서비스에서 재고 차감을 해야한다고 생각 되는데 주문 서비스에서 재고 확인하고, 
  상품 서비스에 재고 차감 요청을 보내면 redis와 db에서 재고차감을 하겠지만 주문 서비스 rest api 통신으로 동기방식으로 처리하면 된다. 
  이러면 성능에 문제가 발생할 것이다. 물론 주문 서비스에서 redis에 재고 차감을 요청하고, redis에서 db에 재고 차감 요청을 보내면 되긴한다. 
  또는 상품 서비스에서 재고차감 요청을 보내자. 이 부분은 고민을 해봐야 겠다.
- 재고가 부족하면, 주문이 거절되거나 대기열에 추가된다.
  - 재고가 부족할 때 대기열 추가는 비즈니스에 따라 구현할 수 도 있고, 아닐 수도 있다.
  - 재고가 부족하면 exception을 던질 것이다.
- 상품의 입고 및 출고 이력을 기록해야 한다.
  - 히스토리 성으로 관리 해야 할 듯
  - 택배사 보면 시간대 별로 나옴
  - Db 설계 생각하기
- 사용자당 동시 다중 주문이 가능하다.
  - 다중 주문시 재고 처리 동시성 생각하기
  - 동시 다중 주문시 순서가 필요할까?
  - 데이터 정합성은 어떻게 해야할까?
  - 주문 상태를 실시간으로 업데이트한다.
  - 실시간이라는게 트랜잭션 관리와 관련이 있다.
  - 모놀리스 형식이면 괜찮짐만 지금은 msa 형식이기에 saga 패턴 사용
- 대량 주문을 안정적으로 처리할 수 있다.
  - Db replication 설정
  - Kafka 사용, DLQ 적용 해보기
  - Redis replication 설정
- 예상치 못한 주문 폭주에도 시스템이 안정적으로 동작한다.
  - 대기열? 스케일 업? 스케일 아웃?
  - 로드밸런싱, 캐싱, 분산 처리를 통해 확장성을 확보한다.
  - 로드밸런싱 사용 여부 확인
  - msa 를 한다면 Api gateway를 사용하여 요청을 관리하고 적절한 서비스에 라우팅 해야 하는데 어떻게 할 지 고민해보기
- 재고 감소 및 주문 생성이 트랜잭션 단위로 처리되어 데이터 무결성을 보장한다.
  - Saga 패턴, 2PC 사용
- 이벤트를 한다면 메시지큐 사용한다면 메시지큐 장애 발생한다면 어떻게 할까?
  - 일단 cluster 구성 하는게 제일 좋다.
  - 하지만 하나의 메시지 큐를 사용한다면 트랜잭션 아웃박스 패턴을 사용하는게 좋지 않을까?
  - 트랜잭션 아웃박스 패턴 사용하면 ‘데이터 일관성’과 메시지 전송의 ‘원자성’ 보장 이 해결 가능하다 판단됨, 이유는 하나의 트랜잭션에서 동작하기 때문에, 그리고 재시도로 데이터 누락이 없다

지금까지 프로젝트 요구사항을 통해 어떻게 구현할까 생각을 정리했다. 다음에는 하나씩 구현하는 시간을 가져보자.

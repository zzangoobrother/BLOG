# 13장 검색어 자동완성 시스템

### 1단계 문제 이해 및 설계 범위 확정

- 사용자가 입력하는 단어는 자동완성될 검색어의 첫 부분
- 표시되는 검색어는 5개
- 질의 빈도에 따라 정해지는 검색어 인기 순위 정렬
- 맞춤법 검사나 자동수정 지원 X
- 다국어 지원
- 모든 질의는 영어 소문자로 가정
- DAU 천만명

#### 요구사항

- 빠른 응답 속도 : 100밀리초 이내
- 연관성 : 사용자가 입력한 단어와 연관될 것
- 정렬 : 인기도 등의 순위 모델에 의해 정렬
- 규모 확장성 : 트래픽을 감당할 수 있도록 확장 가능
- 고가용성 : 일부 장애 발생, 느려지거나, 예상치 못한 네트워크 문제가 생겨도 시스템은 계속 사용 가능

#### 래걀적 규모 추정

- DAU 천만 명
- 사용자는 매일 10건 검색 수행
- 평균 20바이트의 데이터 입력
  - 문자 인코딩 ASCII 사용, 1문자 = 1바이트
  - 질의문은 평균적으로 4개 단어로 이루어진다고 가정, 각 단어는 평균적으로 다섯 글자로 구성된다 가정
  - 질의당 평균 4 * 5 = 20바이트
- 글자 입력 때마다 클라이언트는 검색어 자동완성 백엔드에 요청, 검색당 20건의 요청 전송
- 대략 초당 24,000건의 질의 발생 (10,000,000 * 10 * 20/24/3600)
- 질의 가운데 20% 정도는 신규 검색어, 매일 0.4GB 신규 데이터 추가 (10,000,000 * 10 * 20 * 0.2)

### 2단계 개략적 설계안 제시 및 동의 구하기

- 데이터 수집 서비스 : 사용자가 입력한 질의를 실시간으로 수집하는 시스템, 데이터가 많은 애플리케이션에 실시간 시스템은 그다지 바람지하지 않음
- 질의 서비스 : 주어진 질의 5개의 인기 검색어를 정렬해 내놓은 서비스

#### 데이터 수집 서비스

질의문과 사용빈도를 저장하는 빈도 테이블이 있다고 가정  
사용자가 'twitch', 'twitter', 'twitter', 'twillo'를 순서대로 검색한다.

![image_20250723_1.png](img/image_20250723_1.png)

#### 질의 서비스

![image_20250723_2.png](img/image_20250723_2.png)

- query : 질의문을 저장하는 필드
- frequency : 질의문이 사용된 빈도를 저장

'tw'를 입력하면 top5 자동완성 검색어가 표시, 빈도 테이블에 기록된 수치를 사용해 계산  

```sql
select * from frequency_table
where query like 'prefix%'
order by frequency desc
limit 5
```

### 3단계 상세 설계

#### 트라이 자료구조

관계형 데이터베이스를 이용해 top5 질의문을 골라내는 방안은 비효율적  
이 문제를 해결하기 위해 트라이를 사용  

트라이 자료구조의 핵심 아이디어

- 트라이는 트리 형태의 자료구조
- 트리의 루트 노드는 빈 문자열
- 각 노드는 글자 하나를 저장하며, 26개의 자식 노드를 가짐
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타냄

'tree', 'try', 'true', 'toy', 'wish', 'win' 보관된 트라이  

![image_20250723_3.png](img/image_20250723_3.png)

이용 빈도에 따라 정렬된 결과를 내놓기 위해 노드에 빈도 정보도 저장  

![image_20250723_4.png](img/image_20250723_4.png)

- p : 접두어의 길이
- n : 트라이 안에 있는 노드 개수
- c : 주어진 노드의 자식 노드 개수

가장 많이 사용된 질의어 k개는 다음과 같이 찾음

- 해당 접두어를 표현하는 노드를 찾음, O(p) 시간 복잡도
- 해당 노드부터 시작하는 하위 트리 탐색, 모든 유효 노드 찾음, O(c) 시간 복잡도
- 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개 찾음, O(clogc) 시간 복잡도

k=2, 사용자 'be' 입력

![image_20250723_5.png](img/image_20250723_5.png)

1. 접두어 노드 'be'를 찾음
2. 해당 노드부터 시작하여 하위 트리를 탐색, 모든 유효 노드 찾음
3. 유효 노드 정렬하여 2개만 고름

소요된 시간 복잡도 - O(p) + O(c) + O(clogc)

이 알고리즘은 직관적이지만 최악의 경우 전체 트라이를 다 검색해야 함  

해결 방법

- 접두어의 최대 길이를 제한
- 각 노드에 인기 검색어를 캐시

#### 접두어 최대 길이 제한

검색어의 최대 길이를 제한할 수 있다면 시간 복잡도는 O(p)에서 O(1)로 바꿈

### 노드에 인기 검색어 캐시

각 노드에 k개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지  

![image_20250723_6.png](img/image_20250723_6.png)

최적화 기법을 적용하면 시간 복잡도 변경

- 접두어 노드를 찾는 시간 복잡도는 O(1)
- 최고 인기 검색어 5개를 찾는 질의 시간 복잡도 O(1), 검색 결과가 이미 캐시되어 있기 때문

#### 데이터 수집 서비스

사용자가 검색창에 타이핑 할 때마다 실시간으로 데이터를 수정하면 실용적이지 못 함

- 매일 수천만 건의 질의가 입력, 그때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려짐
- 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않음

규모 확장이 쉬운 데이터 수집 서비스를 만들려면 데이터가 어디서 오고 어떻게 이용되는지 봐야함  
데이터 분석 서비스나 로깅 서비스 봐야함

![image_20250723_7.png](img/image_20250723_7.png)

#### 데이터 분석 서비스 로그


